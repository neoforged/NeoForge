--- a/net/minecraft/resources/HolderSetCodec.java
+++ b/net/minecraft/resources/HolderSetCodec.java
@@ -21,6 +_,8 @@
     private final Codec<Holder<E>> elementCodec;
     private final Codec<List<Holder<E>>> homogenousListCodec;
     private final Codec<Either<TagKey<E>, List<Holder<E>>>> registryAwareCodec;
+    private final Codec<net.neoforged.neoforge.registries.holdersets.ICustomHolderSet<E>> forgeDispatchCodec;
+    private final Codec<Either<net.neoforged.neoforge.registries.holdersets.ICustomHolderSet<E>, Either<TagKey<E>, List<Holder<E>>>>> combinedCodec;
 
     private static <E> Codec<List<Holder<E>>> homogenousList(Codec<Holder<E>> holderCodec, boolean disallowInline) {
         Codec<List<Holder<E>>> codec = holderCodec.listOf().validate(ExtraCodecs.ensureHomogenous(Holder::kind));
@@ -42,6 +_,10 @@
         this.elementCodec = elementCodec;
         this.homogenousListCodec = homogenousList(elementCodec, disallowInline);
         this.registryAwareCodec = Codec.either(TagKey.hashedCodec(registryKey), this.homogenousListCodec);
+        // FORGE: make registry-specific dispatch codec and make forge-or-vanilla either codec
+        this.forgeDispatchCodec = net.neoforged.neoforge.registries.NeoForgeRegistries.HOLDER_SET_TYPES.byNameCodec()
+             .dispatch(net.neoforged.neoforge.registries.holdersets.ICustomHolderSet::type, type -> type.makeCodec(registryKey, elementCodec, disallowInline));
+        this.combinedCodec = Codec.either(this.forgeDispatchCodec, this.registryAwareCodec);
     }
 
     @Override
@@ -50,14 +_,17 @@
             Optional<HolderGetter<E>> optional = registryops.getter(this.registryKey);
             if (optional.isPresent()) {
                 HolderGetter<E> holdergetter = optional.get();
-                return this.registryAwareCodec
-                    .decode(ops, input)
+                // Neo: use the wrapped codec to decode custom/tag/list instead of just tag/list
+                return this.combinedCodec.decode(ops, input)
                     .flatMap(
                         p_337522_ -> {
                             DataResult<HolderSet<E>> dataresult = p_337522_.getFirst()
                                 .map(
+                                    DataResult::success,
+                                    tagOrList -> tagOrList.map(
                                     p_332559_ -> lookupTag(holdergetter, (TagKey<E>)p_332559_),
                                     p_332564_ -> DataResult.success(HolderSet.direct((List<? extends Holder<E>>)p_332564_))
+                                    )
                                 );
                             return dataresult.map(p_332563_ -> Pair.of((HolderSet<E>)p_332563_, (T)p_337522_.getSecond()));
                         }
@@ -82,6 +_,9 @@
                     return DataResult.error(() -> "HolderSet " + input + " is not valid in current registry set");
                 }
 
+                // FORGE: use the dispatch codec to encode custom holdersets, otherwise fall back to vanilla tag/list
+                if (input instanceof net.neoforged.neoforge.registries.holdersets.ICustomHolderSet<E> customHolderSet)
+                     return this.forgeDispatchCodec.encode(customHolderSet, ops, prefix);
                 return this.registryAwareCodec.encode(input.unwrap().mapRight(List::copyOf), ops, prefix);
             }
         }
