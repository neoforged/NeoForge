--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -135,7 +_,7 @@
     private final String storageName;
     private final PlayerMap playerMap = new PlayerMap();
     private final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
-    private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
+    private final Long2ByteMap chunkTypeCache = new net.neoforged.neoforge.common.util.SizeRestrictedLong2ByteLinkedOpenHashMap(net.neoforged.neoforge.common.NeoForgeConfig.SERVER.chunkTypeCacheLimit.get()); // Neo: PR #937
     private final Long2LongMap chunkSaveCooldowns = new Long2LongOpenHashMap();
     private final Queue<Runnable> unloadQueue = Queues.newConcurrentLinkedQueue();
     private int serverViewDistance;
@@ -422,6 +_,7 @@
                 this.modified = true;
             }
 
+            net.neoforged.neoforge.event.EventHooks.fireChunkTicketLevelUpdated(this.level, p_140177_, p_140180_, p_140178_, p_140179_);
             return p_140179_;
         }
     }
@@ -535,6 +_,7 @@
                 if (this.pendingUnloads.remove(p_140182_, p_140183_) && p_203002_ != null) {
                     if (p_203002_ instanceof LevelChunk) {
                         ((LevelChunk)p_203002_).setLoaded(false);
+                        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.ChunkEvent.Unload(p_203002_));
                     }
 
                     this.save(p_203002_);
@@ -735,11 +_,22 @@
             }
 
             levelchunk.setFullStatus(() -> ChunkLevel.fullStatus(p_140384_.getTicketLevel()));
+            try {
+            p_140384_.currentlyLoading = levelchunk; // Neo: bypass the future chain when getChunk is called, this prevents deadlocks.
             levelchunk.runPostLoad();
+            } finally {
+                p_140384_.currentlyLoading = null; // Neo: Stop bypassing the future chain.
+            }
             if (this.entitiesInLevel.add(chunkpos.toLong())) {
                 levelchunk.setLoaded(true);
+                try {
+                p_140384_.currentlyLoading = levelchunk; // Neo: bypass the future chain when getChunk is called, this prevents deadlocks.
                 levelchunk.registerAllBlockEntitiesAfterLevelLoad();
                 levelchunk.registerTickContainerInLevel(this.level);
+                net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.ChunkEvent.Load(levelchunk, !(protochunk instanceof ImposterProtoChunk)));
+                } finally {
+                    p_140384_.currentlyLoading = null; // Neo: Stop bypassing the future chain.
+                }
             }
 
             return levelchunk;
@@ -839,6 +_,7 @@
 
                 this.level.getProfiler().incrementCounter("chunkSave");
                 CompoundTag compoundtag = ChunkSerializer.write(this.level, p_140259_);
+                net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.level.ChunkDataEvent.Save(p_140259_, p_140259_.getLevel() != null ? p_140259_.getLevel() : this.level, compoundtag));
                 this.write(chunkpos, compoundtag).exceptionallyAsync(p_329914_ -> {
                     this.level.getServer().reportChunkSaveFailure(chunkpos);
                     return null;
@@ -901,9 +_,11 @@
 
     private static void markChunkPendingToSend(ServerPlayer p_295834_, LevelChunk p_296281_) {
         p_295834_.connection.chunkSender.markChunkPendingToSend(p_296281_);
+        net.neoforged.neoforge.event.EventHooks.fireChunkWatch(p_295834_, p_296281_, p_295834_.serverLevel());
     }
 
     private static void dropChunk(ServerPlayer p_294215_, ChunkPos p_294758_) {
+        net.neoforged.neoforge.event.EventHooks.fireChunkUnWatch(p_294215_, p_294758_, p_294215_.serverLevel());
         p_294215_.connection.chunkSender.dropChunk(p_294215_, p_294758_);
     }
 
@@ -1102,6 +_,7 @@
                 this.playerMap.unIgnorePlayer(p_140185_);
             }
 
+            //PATCH 1.20.2: Figure out the firing of the watch and unwatch events when chunk tracking updates.
             this.updateChunkTracking(p_140185_);
         }
     }
@@ -1153,7 +_,7 @@
     }
 
     protected void addEntity(Entity p_140200_) {
-        if (!(p_140200_ instanceof EnderDragonPart)) {
+        if (!(p_140200_ instanceof net.neoforged.neoforge.entity.PartEntity)) {
             EntityType<?> entitytype = p_140200_.getType();
             int i = entitytype.clientTrackingRange() * 16;
             if (i != 0) {
@@ -1397,5 +_,12 @@
                 this.updatePlayer(serverplayer);
             }
         }
+    }
+
+    /**
+     * Neo: PR #937
+     */
+    public PoiManager poiManager() {
+        return this.poiManager;
     }
 }
