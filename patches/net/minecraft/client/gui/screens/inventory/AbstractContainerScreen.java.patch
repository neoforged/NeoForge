--- a/net/minecraft/client/gui/screens/inventory/AbstractContainerScreen.java
+++ b/net/minecraft/client/gui/screens/inventory/AbstractContainerScreen.java
@@ -91,7 +_,12 @@
     public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTick) {
         int i = this.leftPos;
         int j = this.topPos;
-        super.render(guiGraphics, mouseX, mouseY, partialTick);
+        // Neo: replicate the super method's implementation to insert the event between background and widgets
+        this.renderBackground(guiGraphics, mouseX, mouseY, partialTick);
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.client.event.ContainerScreenEvent.Render.Background(this, guiGraphics, mouseX, mouseY));
+        for (net.minecraft.client.gui.components.Renderable renderable : this.renderables) {
+            renderable.render(guiGraphics, mouseX, mouseY, partialTick);
+        }
         RenderSystem.disableDepthTest();
         guiGraphics.pose().pushPose();
         guiGraphics.pose().translate((float)i, (float)j, 0.0F);
@@ -105,15 +_,12 @@
 
             if (this.isHovering(slot, (double)mouseX, (double)mouseY) && slot.isActive()) {
                 this.hoveredSlot = slot;
-                int l = slot.x;
-                int i1 = slot.y;
-                if (this.hoveredSlot.isHighlightable()) {
-                    renderSlotHighlight(guiGraphics, l, i1, 0);
-                }
+                this.renderSlotHighlight(guiGraphics, slot, mouseX, mouseY, partialTick);
             }
         }
 
         this.renderLabels(guiGraphics, mouseX, mouseY);
+        net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.client.event.ContainerScreenEvent.Render.Foreground(this, guiGraphics, mouseX, mouseY));
         ItemStack itemstack = this.draggingItem.isEmpty() ? this.menu.getCarried() : this.draggingItem;
         if (!itemstack.isEmpty()) {
             int l1 = 8;
@@ -156,13 +_,25 @@
     }
 
     public static void renderSlotHighlight(GuiGraphics guiGraphics, int x, int y, int blitOffset) {
-        guiGraphics.fillGradient(RenderType.guiOverlay(), x, y, x + 16, y + 16, -2130706433, -2130706433, blitOffset);
+        renderSlotHighlight(guiGraphics, x, y, blitOffset, -2130706433);
+    }
+    public static void renderSlotHighlight(GuiGraphics guiGraphics, int x, int y, int blitOffset, int color) {
+        guiGraphics.fillGradient(RenderType.guiOverlay(), x, y, x + 16, y + 16, color, color, blitOffset);
+    }
+
+    /**
+     * Renders a highlight for the given slot to indicate the mouse is currently hovering over it.
+     */
+    protected void renderSlotHighlight(GuiGraphics guiGraphics, Slot slot, int mouseX, int mouseY, float partialTick) {
+        if (slot.isHighlightable()) {
+            renderSlotHighlight(guiGraphics, slot.x, slot.y, 0, getSlotColor(slot.index));
+        }
     }
 
     protected void renderTooltip(GuiGraphics guiGraphics, int x, int y) {
         if (this.menu.getCarried().isEmpty() && this.hoveredSlot != null && this.hoveredSlot.hasItem()) {
             ItemStack itemstack = this.hoveredSlot.getItem();
-            guiGraphics.renderTooltip(this.font, this.getTooltipFromContainerItem(itemstack), itemstack.getTooltipImage(), x, y);
+            guiGraphics.renderTooltip(this.font, this.getTooltipFromContainerItem(itemstack), itemstack.getTooltipImage(), itemstack, x, y);
         }
     }
 
@@ -174,7 +_,8 @@
         guiGraphics.pose().pushPose();
         guiGraphics.pose().translate(0.0F, 0.0F, 232.0F);
         guiGraphics.renderItem(stack, x, y);
-        guiGraphics.renderItemDecorations(this.font, stack, x, y - (this.draggingItem.isEmpty() ? 0 : 8), text);
+        var font = net.neoforged.neoforge.client.extensions.common.IClientItemExtensions.of(stack).getFont(stack, net.neoforged.neoforge.client.extensions.common.IClientItemExtensions.FontContext.ITEM_COUNT);
+        guiGraphics.renderItemDecorations(font == null ? this.font : font, stack, x, y - (this.draggingItem.isEmpty() ? 0 : 8), text);
         guiGraphics.pose().popPose();
     }
 
@@ -233,6 +_,14 @@
                 guiGraphics.fill(i, j, i + 16, j + 16, -2130706433);
             }
 
+            renderSlotContents(guiGraphics, itemstack, slot, s);
+        }
+
+        guiGraphics.pose().popPose();
+    }
+
+    protected void renderSlotContents(GuiGraphics guiGraphics, ItemStack itemstack, Slot slot, @Nullable String countString) {
+            String s = countString; int i = slot.x; int j = slot.y;
             int j1 = slot.x + slot.y * this.imageWidth;
             if (slot.isFake()) {
                 guiGraphics.renderFakeItem(itemstack, i, j, j1);
@@ -241,9 +_,6 @@
             }
 
             guiGraphics.renderItemDecorations(this.font, itemstack, i, j, s);
-        }
-
-        guiGraphics.pose().popPose();
     }
 
     private void recalculateQuickCraftRemaining() {
@@ -282,7 +_,8 @@
         if (super.mouseClicked(mouseX, mouseY, button)) {
             return true;
         } else {
-            boolean flag = this.minecraft.options.keyPickItem.matchesMouse(button) && this.minecraft.gameMode.hasInfiniteItems();
+            InputConstants.Key mouseKey = InputConstants.Type.MOUSE.getOrCreate(button);
+            boolean flag = this.minecraft.options.keyPickItem.isActiveAndMatches(mouseKey);
             Slot slot = this.findSlot(mouseX, mouseY);
             long i = Util.getMillis();
             this.doubleclick = this.lastClickSlot == slot && i - this.lastClickTime < 250L && this.lastClickButton == button;
@@ -293,6 +_,7 @@
                 int j = this.leftPos;
                 int k = this.topPos;
                 boolean flag1 = this.hasClickedOutside(mouseX, mouseY, j, k, button);
+                if (slot != null) flag1 = false; // Forge, prevent dropping of items through slots outside of GUI boundaries
                 int l = -1;
                 if (slot != null) {
                     l = slot.index;
@@ -318,7 +_,7 @@
                         }
                     } else if (!this.isQuickCrafting) {
                         if (this.menu.getCarried().isEmpty()) {
-                            if (flag) {
+                            if (this.minecraft.options.keyPickItem.isActiveAndMatches(mouseKey)) {
                                 this.slotClicked(slot, l, button, ClickType.CLONE);
                             } else {
                                 boolean flag2 = l != -999
@@ -346,7 +_,7 @@
                                 this.quickCraftingType = 0;
                             } else if (button == 1) {
                                 this.quickCraftingType = 1;
-                            } else if (flag) {
+                            } else if (this.minecraft.options.keyPickItem.isActiveAndMatches(mouseKey)) {
                                 this.quickCraftingType = 2;
                             }
                         }
@@ -425,10 +_,13 @@
 
     @Override
     public boolean mouseReleased(double mouseX, double mouseY, int button) {
+        super.mouseReleased(mouseX, mouseY, button); //Forge, Call parent to release buttons
         Slot slot = this.findSlot(mouseX, mouseY);
         int i = this.leftPos;
         int j = this.topPos;
         boolean flag = this.hasClickedOutside(mouseX, mouseY, i, j, button);
+        if (slot != null) flag = false; // Forge, prevent dropping of items through slots outside of GUI boundaries
+        InputConstants.Key mouseKey = InputConstants.Type.MOUSE.getOrCreate(button);
         int k = -1;
         if (slot != null) {
             k = slot.index;
@@ -445,7 +_,7 @@
                         if (slot2 != null
                             && slot2.mayPickup(this.minecraft.player)
                             && slot2.hasItem()
-                            && slot2.container == slot.container
+                            && slot2.isSameInventory(slot)
                             && AbstractContainerMenu.canItemQuickReplace(slot2, this.lastQuickMoved, true)) {
                             this.slotClicked(slot2, slot2.index, button, ClickType.QUICK_MOVE);
                         }
@@ -509,7 +_,7 @@
 
                 this.slotClicked(null, -999, AbstractContainerMenu.getQuickcraftMask(2, this.quickCraftingType), ClickType.QUICK_CRAFT);
             } else if (!this.menu.getCarried().isEmpty()) {
-                if (this.minecraft.options.keyPickItem.matchesMouse(button)) {
+                if (this.minecraft.options.keyPickItem.isActiveAndMatches(mouseKey)) {
                     this.slotClicked(slot, k, button, ClickType.CLONE);
                 } else {
                     boolean flag1 = k != -999
@@ -568,34 +_,39 @@
 
     @Override
     public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
+        InputConstants.Key mouseKey = InputConstants.getKey(keyCode, scanCode);
         if (super.keyPressed(keyCode, scanCode, modifiers)) {
             return true;
-        } else if (this.minecraft.options.keyInventory.matches(keyCode, scanCode)) {
+        } else if (this.minecraft.options.keyInventory.isActiveAndMatches(mouseKey)) {
             this.onClose();
             return true;
         } else {
-            this.checkHotbarKeyPressed(keyCode, scanCode);
+            boolean handled = this.checkHotbarKeyPressed(keyCode, scanCode);// Forge MC-146650: Needs to return true when the key is handled
             if (this.hoveredSlot != null && this.hoveredSlot.hasItem()) {
-                if (this.minecraft.options.keyPickItem.matches(keyCode, scanCode)) {
+                if (this.minecraft.options.keyPickItem.isActiveAndMatches(mouseKey)) {
                     this.slotClicked(this.hoveredSlot, this.hoveredSlot.index, 0, ClickType.CLONE);
-                } else if (this.minecraft.options.keyDrop.matches(keyCode, scanCode)) {
+                    handled = true;
+                } else if (this.minecraft.options.keyDrop.isActiveAndMatches(mouseKey)) {
                     this.slotClicked(this.hoveredSlot, this.hoveredSlot.index, hasControlDown() ? 1 : 0, ClickType.THROW);
+                    handled = true;
                 }
+            } else if (this.minecraft.options.keyDrop.isActiveAndMatches(mouseKey)) {
+                 handled = true; // Forge MC-146650: Emulate MC bug, so we don't drop from hotbar when pressing drop without hovering over a item.
             }
 
-            return true;
+            return handled;
         }
     }
 
     protected boolean checkHotbarKeyPressed(int keyCode, int scanCode) {
         if (this.menu.getCarried().isEmpty() && this.hoveredSlot != null) {
-            if (this.minecraft.options.keySwapOffhand.matches(keyCode, scanCode)) {
+            if (this.minecraft.options.keySwapOffhand.isActiveAndMatches(InputConstants.getKey(keyCode, scanCode))) {
                 this.slotClicked(this.hoveredSlot, this.hoveredSlot.index, 40, ClickType.SWAP);
                 return true;
             }
 
             for (int i = 0; i < 9; i++) {
-                if (this.minecraft.options.keyHotbarSlots[i].matches(keyCode, scanCode)) {
+                if (this.minecraft.options.keyHotbarSlots[i].isActiveAndMatches(InputConstants.getKey(keyCode, scanCode))) {
                     this.slotClicked(this.hoveredSlot, this.hoveredSlot.index, i, ClickType.SWAP);
                     return true;
                 }
@@ -633,6 +_,18 @@
     @Override
     public T getMenu() {
         return this.menu;
+    }
+
+    @org.jetbrains.annotations.Nullable
+    public Slot getSlotUnderMouse() { return this.hoveredSlot; }
+    public int getGuiLeft() { return leftPos; }
+    public int getGuiTop() { return topPos; }
+    public int getXSize() { return imageWidth; }
+    public int getYSize() { return imageHeight; }
+
+    protected int slotColor = -2130706433;
+    public int getSlotColor(int index) {
+        return slotColor;
     }
 
     @Override
