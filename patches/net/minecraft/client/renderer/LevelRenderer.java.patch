--- a/net/minecraft/client/renderer/LevelRenderer.java
+++ b/net/minecraft/client/renderer/LevelRenderer.java
@@ -256,6 +_,8 @@
     }
 
     private void renderSnowAndRain(LightTexture lightTexture, float partialTick, double camX, double camY, double camZ) {
+        if (level.effects().renderSnowAndRain(level, ticks, partialTick, lightTexture, camX, camY, camZ))
+            return;
         float f = this.minecraft.level.getRainLevel(partialTick);
         if (!(f <= 0.0F)) {
             lightTexture.turnOnLightLayer();
@@ -418,6 +_,8 @@
     }
 
     public void tickRain(Camera camera) {
+        if (level.effects().tickRain(level, ticks, camera))
+            return;
         float f = this.minecraft.level.getRainLevel(1.0F) / (Minecraft.useFancyGraphics() ? 1.0F : 2.0F);
         if (!(f <= 0.0F)) {
             RandomSource randomsource = RandomSource.create((long)this.ticks * 312987231L);
@@ -942,9 +_,11 @@
         RenderSystem.clear(16640, Minecraft.ON_OSX);
         float f1 = gameRenderer.getRenderDistance();
         boolean flag1 = this.minecraft.level.effects().isFoggyAt(Mth.floor(d0), Mth.floor(d1)) || this.minecraft.gui.getBossOverlay().shouldCreateWorldFog();
+        FogRenderer.setupFog(camera, FogRenderer.FogMode.FOG_SKY, f1, flag1, f);
         profilerfiller.popPush("sky");
         RenderSystem.setShader(GameRenderer::getPositionShader);
         this.renderSky(frustumMatrix, projectionMatrix, f, camera, flag1, () -> FogRenderer.setupFog(camera, FogRenderer.FogMode.FOG_SKY, f1, flag1, f));
+        net.neoforged.neoforge.client.ClientHooks.dispatchRenderStage(net.neoforged.neoforge.client.event.RenderLevelStageEvent.Stage.AFTER_SKY, this, null, frustumMatrix, projectionMatrix, this.ticks, camera, frustum);
         profilerfiller.popPush("fog");
         FogRenderer.setupFog(camera, FogRenderer.FogMode.FOG_TERRAIN, Math.max(f1, 32.0F), flag1, f);
         profilerfiller.popPush("terrain_setup");
@@ -953,7 +_,9 @@
         this.compileSections(camera);
         profilerfiller.popPush("terrain");
         this.renderSectionLayer(RenderType.solid(), d0, d1, d2, frustumMatrix, projectionMatrix);
+        this.minecraft.getModelManager().getAtlas(TextureAtlas.LOCATION_BLOCKS).setBlurMipmap(false, this.minecraft.options.mipmapLevels().get() > 0); // Neo: fix flickering leaves when mods mess up the blurMipmap settings
         this.renderSectionLayer(RenderType.cutoutMipped(), d0, d1, d2, frustumMatrix, projectionMatrix);
+        this.minecraft.getModelManager().getAtlas(TextureAtlas.LOCATION_BLOCKS).restoreLastBlurMipmap();
         this.renderSectionLayer(RenderType.cutout(), d0, d1, d2, frustumMatrix, projectionMatrix);
         if (this.level.effects().constantAmbientLight()) {
             Lighting.setupNetherLevel();
@@ -996,7 +_,7 @@
                             || camera.isDetached()
                             || camera.getEntity() instanceof LivingEntity && ((LivingEntity)camera.getEntity()).isSleeping()
                     )
-                    && (!(entity instanceof LocalPlayer) || camera.getEntity() == entity)) {
+                    && (!(entity instanceof LocalPlayer) || camera.getEntity() == entity || (entity == minecraft.player && !minecraft.player.isSpectator()))) { // Neo: render local player entity when it is not the camera entity
                     this.renderedEntities++;
                     if (entity.tickCount == 0) {
                         entity.xOld = entity.getX();
@@ -1012,6 +_,9 @@
                         int i = entity.getTeamColor();
                         outlinebuffersource.setColor(FastColor.ARGB32.red(i), FastColor.ARGB32.green(i), FastColor.ARGB32.blue(i), 255);
                     } else {
+                        if (this.shouldShowEntityOutlines() && entity.hasCustomOutlineRendering(this.minecraft.player)) { // FORGE: allow custom outline rendering
+                            flag2 = true;
+                        }
                         multibuffersource = multibuffersource$buffersource;
                     }
 
@@ -1027,12 +_,14 @@
         multibuffersource$buffersource.endBatch(RenderType.entityCutout(TextureAtlas.LOCATION_BLOCKS));
         multibuffersource$buffersource.endBatch(RenderType.entityCutoutNoCull(TextureAtlas.LOCATION_BLOCKS));
         multibuffersource$buffersource.endBatch(RenderType.entitySmoothCutout(TextureAtlas.LOCATION_BLOCKS));
+        net.neoforged.neoforge.client.ClientHooks.dispatchRenderStage(net.neoforged.neoforge.client.event.RenderLevelStageEvent.Stage.AFTER_ENTITIES, this, posestack, frustumMatrix, projectionMatrix, this.ticks, camera, frustum);
         profilerfiller.popPush("blockentities");
 
         for (SectionRenderDispatcher.RenderSection sectionrenderdispatcher$rendersection : this.visibleSections) {
             List<BlockEntity> list = sectionrenderdispatcher$rendersection.getCompiled().getRenderableBlockEntities();
             if (!list.isEmpty()) {
                 for (BlockEntity blockentity1 : list) {
+                    if (!net.neoforged.neoforge.client.ClientHooks.isBlockEntityRendererVisible(blockEntityRenderDispatcher, blockentity1, frustum)) continue;
                     BlockPos blockpos4 = blockentity1.getBlockPos();
                     MultiBufferSource multibuffersource1 = multibuffersource$buffersource;
                     posestack.pushPose();
@@ -1051,6 +_,9 @@
                             };
                         }
                     }
+                    if (this.shouldShowEntityOutlines() && blockentity1.hasCustomOutlineRendering(this.minecraft.player)) { // Neo: allow custom outline rendering
+                        flag2 = true;
+                    }
 
                     this.blockEntityRenderDispatcher.render(blockentity1, f, posestack, multibuffersource1);
                     posestack.popPose();
@@ -1060,9 +_,13 @@
 
         synchronized (this.globalBlockEntities) {
             for (BlockEntity blockentity : this.globalBlockEntities) {
+                if (!net.neoforged.neoforge.client.ClientHooks.isBlockEntityRendererVisible(blockEntityRenderDispatcher, blockentity, frustum)) continue;
                 BlockPos blockpos3 = blockentity.getBlockPos();
                 posestack.pushPose();
                 posestack.translate((double)blockpos3.getX() - d0, (double)blockpos3.getY() - d1, (double)blockpos3.getZ() - d2);
+                if (this.shouldShowEntityOutlines() && blockentity.hasCustomOutlineRendering(this.minecraft.player)) { // Neo: allow custom outline rendering
+                    flag2 = true;
+                }
                 this.blockEntityRenderDispatcher.render(blockentity, f, posestack, multibuffersource$buffersource);
                 posestack.popPose();
             }
@@ -1085,6 +_,7 @@
             this.minecraft.getMainRenderTarget().bindWrite(false);
         }
 
+        net.neoforged.neoforge.client.ClientHooks.dispatchRenderStage(net.neoforged.neoforge.client.event.RenderLevelStageEvent.Stage.AFTER_BLOCK_ENTITIES, this, posestack, frustumMatrix, projectionMatrix, this.ticks, camera, frustum);
         profilerfiller.popPush("destroyProgress");
 
         for (Entry<SortedSet<BlockDestructionProgress>> entry : this.destructionProgress.long2ObjectEntrySet()) {
@@ -1102,9 +_,10 @@
                     VertexConsumer vertexconsumer1 = new SheetedDecalTextureGenerator(
                         this.renderBuffers.crumblingBufferSource().getBuffer(ModelBakery.DESTROY_TYPES.get(k)), posestack$pose1, 1.0F
                     );
+                    net.neoforged.neoforge.client.model.data.ModelData modelData = level.getModelData(blockpos2);
                     this.minecraft
                         .getBlockRenderer()
-                        .renderBreakingTexture(this.level.getBlockState(blockpos2), blockpos2, this.level, posestack, vertexconsumer1);
+                        .renderBreakingTexture(this.level.getBlockState(blockpos2), blockpos2, this.level, posestack, vertexconsumer1, modelData);
                     posestack.popPose();
                 }
             }
@@ -1116,10 +_,13 @@
             profilerfiller.popPush("outline");
             BlockPos blockpos1 = ((BlockHitResult)hitresult).getBlockPos();
             BlockState blockstate = this.level.getBlockState(blockpos1);
+            if (!net.neoforged.neoforge.client.ClientHooks.onDrawHighlight(this, camera, hitresult, deltaTracker, posestack, multibuffersource$buffersource))
             if (!blockstate.isAir() && this.level.getWorldBorder().isWithinBounds(blockpos1)) {
                 VertexConsumer vertexconsumer2 = multibuffersource$buffersource.getBuffer(RenderType.lines());
                 this.renderHitOutline(posestack, vertexconsumer2, camera.getEntity(), d0, d1, d2, blockpos1, blockstate);
             }
+        } else if (hitresult != null && hitresult.getType() == HitResult.Type.ENTITY) {
+            net.neoforged.neoforge.client.ClientHooks.onDrawHighlight(this, camera, hitresult, deltaTracker, posestack, multibuffersource$buffersource);
         }
 
         this.minecraft.debugRenderer.render(posestack, multibuffersource$buffersource, d0, d1, d2);
@@ -1147,9 +_,13 @@
             this.particlesTarget.copyDepthFrom(this.minecraft.getMainRenderTarget());
             RenderStateShard.PARTICLES_TARGET.setupRenderState();
             profilerfiller.popPush("particles");
-            this.minecraft.particleEngine.render(lightTexture, camera, f);
+            this.minecraft.particleEngine.render(lightTexture, camera, f, frustum, type -> true);
+            net.neoforged.neoforge.client.ClientHooks.dispatchRenderStage(net.neoforged.neoforge.client.event.RenderLevelStageEvent.Stage.AFTER_PARTICLES, this, posestack, frustumMatrix, projectionMatrix, this.ticks, camera, frustum);
             RenderStateShard.PARTICLES_TARGET.clearRenderState();
         } else {
+            // Neo: render solid particles before translucent geometry to match order of chunk render types, fixes solid particles disappearing underwater in Fast/Fancy (MC-161917)
+            profilerfiller.popPush("solid_particles");
+            this.minecraft.particleEngine.render(lightTexture, camera, f, frustum, type -> !type.isTranslucent());
             profilerfiller.popPush("translucent");
             if (this.translucentTarget != null) {
                 this.translucentTarget.clear(Minecraft.ON_OSX);
@@ -1161,7 +_,8 @@
             profilerfiller.popPush("string");
             this.renderSectionLayer(RenderType.tripwire(), d0, d1, d2, frustumMatrix, projectionMatrix);
             profilerfiller.popPush("particles");
-            this.minecraft.particleEngine.render(lightTexture, camera, f);
+            this.minecraft.particleEngine.render(lightTexture, camera, f, frustum, type -> type.isTranslucent()); // Neo: only render translucent particles at this stage
+            net.neoforged.neoforge.client.ClientHooks.dispatchRenderStage(net.neoforged.neoforge.client.event.RenderLevelStageEvent.Stage.AFTER_PARTICLES, this, posestack, frustumMatrix, projectionMatrix, this.ticks, camera, frustum);
         }
 
         if (this.minecraft.options.getCloudsType() != CloudStatus.OFF) {
@@ -1177,6 +_,7 @@
             RenderStateShard.WEATHER_TARGET.setupRenderState();
             profilerfiller.popPush("weather");
             this.renderSnowAndRain(lightTexture, f, d0, d1, d2);
+            net.neoforged.neoforge.client.ClientHooks.dispatchRenderStage(net.neoforged.neoforge.client.event.RenderLevelStageEvent.Stage.AFTER_WEATHER, this, posestack, frustumMatrix, projectionMatrix, this.ticks, camera, frustum);
             this.renderWorldBorder(camera);
             RenderStateShard.WEATHER_TARGET.clearRenderState();
             this.transparencyChain.process(deltaTracker.getGameTimeDeltaTicks());
@@ -1185,6 +_,7 @@
             RenderSystem.depthMask(false);
             profilerfiller.popPush("weather");
             this.renderSnowAndRain(lightTexture, f, d0, d1, d2);
+            net.neoforged.neoforge.client.ClientHooks.dispatchRenderStage(net.neoforged.neoforge.client.event.RenderLevelStageEvent.Stage.AFTER_WEATHER, this, posestack, frustumMatrix, projectionMatrix, this.ticks, camera, frustum);
             this.renderWorldBorder(camera);
             RenderSystem.depthMask(true);
         }
@@ -1293,6 +_,7 @@
         shaderinstance.clear();
         VertexBuffer.unbind();
         this.minecraft.getProfiler().pop();
+        net.neoforged.neoforge.client.ClientHooks.dispatchRenderStage(renderType, this, frustrumMatrix, projectionMatrix, this.ticks, this.minecraft.gameRenderer.getMainCamera(), this.getFrustum());
         renderType.clearRenderState();
     }
 
@@ -1543,6 +_,8 @@
     }
 
     public void renderSky(Matrix4f frustumMatrix, Matrix4f projectionMatrix, float partialTick, Camera camera, boolean isFoggy, Runnable skyFogSetup) {
+        if (level.effects().renderSky(level, ticks, partialTick, frustumMatrix, camera, projectionMatrix, isFoggy, skyFogSetup))
+            return;
         skyFogSetup.run();
         if (!isFoggy) {
             FogType fogtype = camera.getFluidInCamera();
@@ -1666,6 +_,8 @@
     }
 
     public void renderClouds(PoseStack poseStack, Matrix4f frustumMatrix, Matrix4f projectionMatrix, float partialTick, double camX, double camY, double camZ) {
+        if (level.effects().renderClouds(level, ticks, partialTick, poseStack, camX, camY, camZ, frustumMatrix, projectionMatrix))
+            return;
         float f = this.level.effects().getCloudHeight();
         if (!Float.isNaN(f)) {
             float f1 = 12.0F;
@@ -2488,6 +_,23 @@
         this.viewArea.setDirty(sectionX, sectionY, sectionZ, reRenderOnMainThread);
     }
 
+    public Frustum getFrustum() {
+        return this.capturedFrustum != null ? this.capturedFrustum : this.cullingFrustum;
+    }
+
+    public int getTicks() {
+        return this.ticks;
+    }
+
+    public void iterateVisibleBlockEntities(java.util.function.Consumer<BlockEntity> blockEntityConsumer) {
+        for (var chunkInfo : this.visibleSections) {
+            chunkInfo.getCompiled().getRenderableBlockEntities().forEach(blockEntityConsumer);
+        }
+        synchronized (this.globalBlockEntities) {
+            this.globalBlockEntities.forEach(blockEntityConsumer);
+        }
+    }
+
     public void playJukeboxSong(Holder<JukeboxSong> song, BlockPos pos) {
         if (this.level != null) {
             this.stopJukeboxSong(pos);
@@ -3008,8 +_,8 @@
                 break;
             case 2001:
                 BlockState blockstate1 = Block.stateById(data);
-                if (!blockstate1.isAir()) {
-                    SoundType soundtype = blockstate1.getSoundType();
+                if (!blockstate1.isAir() && !net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions.of(blockstate1).playBreakSound(blockstate1, this.level, pos)) {
+                    SoundType soundtype = blockstate1.getSoundType(this.level, pos, null);
                     this.level
                         .playLocalSound(
                             pos, soundtype.getBreakSound(), SoundSource.BLOCKS, (soundtype.getVolume() + 1.0F) / 2.0F, soundtype.getPitch() * 0.8F, false
@@ -3495,7 +_,7 @@
         } else {
             int i = level.getBrightness(LightLayer.SKY, pos);
             int j = level.getBrightness(LightLayer.BLOCK, pos);
-            int k = state.getLightEmission();
+            int k = state.getLightEmission(level, pos);
             if (j < k) {
                 j = k;
             }
