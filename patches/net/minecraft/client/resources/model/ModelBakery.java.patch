--- a/net/minecraft/client/resources/model/ModelBakery.java
+++ b/net/minecraft/client/resources/model/ModelBakery.java
@@ -117,6 +_,12 @@
         profilerFiller.popPush("special");
         this.loadSpecialItemModelAndDependencies(ItemRenderer.TRIDENT_IN_HAND_MODEL);
         this.loadSpecialItemModelAndDependencies(ItemRenderer.SPYGLASS_IN_HAND_MODEL);
+        Set<ModelResourceLocation> additionalModels = new HashSet<>();
+        net.neoforged.neoforge.client.ClientHooks.onRegisterAdditionalModels(additionalModels);
+        for (ModelResourceLocation rl : additionalModels) {
+            UnbakedModel unbakedmodel = this.getModel(rl.id());
+            this.registerModelAndLoadDependencies(rl, unbakedmodel);
+        }
         this.topLevelModels.values().forEach(p_247954_ -> p_247954_.resolveParents(this::getModel));
         profilerFiller.pop();
     }
@@ -246,14 +_,30 @@
         }
 
         @Override
+        @Nullable
+        public UnbakedModel getTopLevelModel(ModelResourceLocation location) {
+            return topLevelModels.get(location);
+        }
+
+        @Override
+        public Function<Material, TextureAtlasSprite> getModelTextureGetter() {
+            return this.modelTextureGetter;
+        }
+
+        @Override
         public BakedModel bake(ResourceLocation location, ModelState transform) {
+            return bake(location, transform, this.modelTextureGetter);
+        }
+
+        @Override
+        public BakedModel bake(ResourceLocation location, ModelState transform, Function<Material, TextureAtlasSprite> sprites) {
             ModelBakery.BakedCacheKey modelbakery$bakedcachekey = new ModelBakery.BakedCacheKey(location, transform.getRotation(), transform.isUvLocked());
             BakedModel bakedmodel = ModelBakery.this.bakedCache.get(modelbakery$bakedcachekey);
             if (bakedmodel != null) {
                 return bakedmodel;
             } else {
                 UnbakedModel unbakedmodel = this.getModel(location);
-                BakedModel bakedmodel1 = this.bakeUncached(unbakedmodel, transform);
+                BakedModel bakedmodel1 = this.bakeUncached(unbakedmodel, transform, sprites);
                 ModelBakery.this.bakedCache.put(modelbakery$bakedcachekey, bakedmodel1);
                 return bakedmodel1;
             }
@@ -261,13 +_,19 @@
 
         @Nullable
         BakedModel bakeUncached(UnbakedModel model, ModelState state) {
+            return bakeUncached(model, state, this.modelTextureGetter);
+        }
+
+        @Override
+        @Nullable
+        public BakedModel bakeUncached(UnbakedModel model, ModelState state, Function<Material, TextureAtlasSprite> sprites) {
             if (model instanceof BlockModel blockmodel && blockmodel.getRootModel() == ModelBakery.GENERATION_MARKER) {
                 return ModelBakery.ITEM_MODEL_GENERATOR
-                    .generateBlockModel(this.modelTextureGetter, blockmodel)
-                    .bake(this, blockmodel, this.modelTextureGetter, state, false);
+                    .generateBlockModel(sprites, blockmodel)
+                    .bake(this, blockmodel, sprites, state, false);
             }
 
-            return model.bake(this, this.modelTextureGetter, state);
+            return model.bake(this, sprites, state);
         }
     }
 
