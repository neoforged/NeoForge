--- a/net/minecraft/client/resources/model/ModelManager.java
+++ b/net/minecraft/client/resources/model/ModelManager.java
@@ -41,7 +_,7 @@
 import org.slf4j.Logger;
 
 @OnlyIn(Dist.CLIENT)
-public class ModelManager implements PreparableReloadListener, AutoCloseable {
+public class ModelManager extends net.neoforged.neoforge.resource.ContextAwareReloadListener implements PreparableReloadListener, AutoCloseable {
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final Map<ResourceLocation, ResourceLocation> VANILLA_ATLASES = Map.of(
         Sheets.BANNER_SHEET,
@@ -63,13 +_,14 @@
         TextureAtlas.LOCATION_BLOCKS,
         ResourceLocation.withDefaultNamespace("blocks")
     );
-    private Map<ModelResourceLocation, BakedModel> bakedRegistry;
+    private Map<ModelResourceLocation, BakedModel> bakedRegistry = new java.util.HashMap<>();
     private final AtlasSet atlases;
     private final BlockModelShaper blockModelShaper;
     private final BlockColors blockColors;
     private int maxMipmapLevels;
     private BakedModel missingModel;
     private Object2IntMap<BlockState> modelGroups;
+    private ModelBakery modelBakery;
 
     public ModelManager(TextureManager p_119406_, BlockColors p_119407_, int p_119408_) {
         this.blockColors = p_119407_;
@@ -100,14 +_,15 @@
         Executor p_249221_
     ) {
         p_250336_.startTick();
-        CompletableFuture<Map<ResourceLocation, BlockModel>> completablefuture = loadBlockModels(p_251134_, p_250550_);
+        CompletableFuture<Map<ResourceLocation, net.neoforged.neoforge.client.resource.model.TopLevelUnbakedModel>> completablefuture = loadUnbakedModels(this.makeConditionalOps(), p_251134_, p_250550_);
+        /*CompletableFuture<Map<ResourceLocation, BlockModel>> completablefuture = loadBlockModels(p_251134_, p_250550_);*/
         CompletableFuture<Map<ResourceLocation, List<BlockStateModelLoader.LoadedJson>>> completablefuture1 = loadBlockStates(p_251134_, p_250550_);
         CompletableFuture<ModelBakery> completablefuture2 = completablefuture.thenCombineAsync(
             completablefuture1,
             (p_251201_, p_251281_) -> new ModelBakery(
                     this.blockColors,
                     p_250336_,
-                    (Map<ResourceLocation, BlockModel>)p_251201_,
+                    (Map<ResourceLocation, net.neoforged.neoforge.client.resource.model.TopLevelUnbakedModel>)p_251201_,
                     (Map<ResourceLocation, List<BlockStateModelLoader.LoadedJson>>)p_251281_
                 ),
             p_250550_
@@ -128,17 +_,22 @@
     }
 
     private static CompletableFuture<Map<ResourceLocation, BlockModel>> loadBlockModels(ResourceManager p_251361_, Executor p_252189_) {
+        // Unchecked cast here is intentional
+        return (CompletableFuture<Map<ResourceLocation, BlockModel>>)(CompletableFuture)loadUnbakedModels(com.mojang.serialization.JsonOps.INSTANCE, p_251361_, p_252189_);
+    }
+
+    private static CompletableFuture<Map<ResourceLocation, net.neoforged.neoforge.client.resource.model.TopLevelUnbakedModel>> loadUnbakedModels(com.mojang.serialization.DynamicOps<com.google.gson.JsonElement> ops, ResourceManager p_251361_, Executor p_252189_) {
         return CompletableFuture.<Map<ResourceLocation, Resource>>supplyAsync(() -> ModelBakery.MODEL_LISTER.listMatchingResources(p_251361_), p_252189_)
             .thenCompose(
                 p_250597_ -> {
-                    List<CompletableFuture<Pair<ResourceLocation, BlockModel>>> list = new ArrayList<>(p_250597_.size());
+                    List<CompletableFuture<Pair<ResourceLocation, net.neoforged.neoforge.client.resource.model.TopLevelUnbakedModel>>> list = new ArrayList<>(p_250597_.size());
 
                     for (Entry<ResourceLocation, Resource> entry : p_250597_.entrySet()) {
                         list.add(CompletableFuture.supplyAsync(() -> {
                             try {
                                 Pair pair;
                                 try (Reader reader = entry.getValue().openAsReader()) {
-                                    pair = Pair.of(entry.getKey(), BlockModel.fromStream(reader));
+                                    pair = Pair.of(entry.getKey(), net.neoforged.neoforge.client.resource.model.ModelManagerHooks.loadUnbakedModel(ops, reader));
                                 }
 
                                 return pair;
@@ -218,6 +_,8 @@
                             .collect(Collectors.joining("\n"))
                     )
             );
+        p_252136_.popPush("forge_modify_baking_result");
+        net.neoforged.neoforge.client.ClientHooks.onModifyBakingResult(p_248945_.getBakedTopLevelModels(), p_250646_, p_248945_);
         p_252136_.popPush("dispatch");
         Map<ModelResourceLocation, BakedModel> map = p_248945_.getBakedTopLevelModels();
         BakedModel bakedmodel = map.get(ModelBakery.MISSING_MODEL_VARIANT);
@@ -247,6 +_,8 @@
         this.bakedRegistry = modelbakery.getBakedTopLevelModels();
         this.modelGroups = modelbakery.getModelGroups();
         this.missingModel = p_248996_.missingModel;
+        this.modelBakery = modelbakery;
+        net.neoforged.neoforge.client.ClientHooks.onModelBake(this, this.bakedRegistry, modelbakery);
         p_251960_.popPush("cache");
         this.blockModelShaper.replaceCache(p_248996_.modelCache);
         p_251960_.pop();
@@ -272,6 +_,7 @@
     }
 
     public TextureAtlas getAtlas(ResourceLocation p_119429_) {
+        if (this.atlases == null) throw new RuntimeException("getAtlasTexture called too early!");
         return this.atlases.getAtlas(p_119429_);
     }
 
@@ -282,6 +_,10 @@
 
     public void updateMaxMipLevel(int p_119411_) {
         this.maxMipmapLevels = p_119411_;
+    }
+
+    public ModelBakery getModelBakery() {
+        return com.google.common.base.Preconditions.checkNotNull(modelBakery, "Attempted to query model bakery before it has been initialized.");
     }
 
     @OnlyIn(Dist.CLIENT)
