--- a/net/minecraft/world/level/block/Block.java
+++ b/net/minecraft/world/level/block/Block.java
@@ -61,11 +_,11 @@
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.slf4j.Logger;
 
-public class Block extends BlockBehaviour implements ItemLike {
+public class Block extends BlockBehaviour implements ItemLike, net.neoforged.neoforge.common.extensions.IBlockExtension {
     public static final MapCodec<Block> CODEC = simpleCodec(Block::new);
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder = BuiltInRegistries.BLOCK.createIntrusiveHolder(this);
-    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
+    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = net.neoforged.neoforge.registries.GameData.getBlockStateIDMap();
     private static final LoadingCache<VoxelShape, Boolean> SHAPE_FULL_BLOCK_CACHE = CacheBuilder.newBuilder()
         .maximumSize(512L)
         .weakKeys()
@@ -186,12 +_,13 @@
         this.createBlockStateDefinition(builder);
         this.stateDefinition = builder.create(Block::defaultBlockState, BlockState::new);
         this.registerDefaultState(this.stateDefinition.any());
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
+        if (SharedConstants.IS_RUNNING_IN_IDE && false) {
             String s = this.getClass().getSimpleName();
             if (!s.endsWith("Block")) {
                 LOGGER.error("Block classes should end with Block and {} doesn't.", s);
             }
         }
+        initClient();
     }
 
     public static boolean isExceptionForConnection(BlockState state) {
@@ -208,6 +_,8 @@
         BlockState blockstate = level.getBlockState(pos);
         if (state.skipRendering(blockstate, face)) {
             return false;
+        } else if (blockstate.hidesNeighborFace(level, pos, state, face.getOpposite()) && state.supportsExternalFaceHiding()) {
+            return false;
         } else if (blockstate.canOcclude()) {
             Block.BlockStatePairKey block$blockstatepairkey = new Block.BlockStatePairKey(state, blockstate, face);
             Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey> object2bytelinkedopenhashmap = OCCLUSION_CACHE.get();
@@ -281,24 +_,30 @@
 
     public static void dropResources(BlockState state, Level level, BlockPos pos) {
         if (level instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(state, (ServerLevel)level, pos, null).forEach(p_152406_ -> popResource(level, pos, p_152406_));
-            state.spawnAfterBreak((ServerLevel)level, pos, ItemStack.EMPTY, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) level, pos, state, null, captured, null, ItemStack.EMPTY);
         }
     }
 
     public static void dropResources(BlockState state, LevelAccessor level, BlockPos pos, @Nullable BlockEntity blockEntity) {
         if (level instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(state, (ServerLevel)level, pos, blockEntity).forEach(p_49859_ -> popResource((ServerLevel)level, pos, p_49859_));
-            state.spawnAfterBreak((ServerLevel)level, pos, ItemStack.EMPTY, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) level, pos, state, blockEntity, captured, null, ItemStack.EMPTY);
         }
     }
 
     public static void dropResources(
-        BlockState state, Level level, BlockPos pos, @Nullable BlockEntity blockEntity, @Nullable Entity entity, ItemStack tool
+            BlockState state, Level level, BlockPos pos, @Nullable BlockEntity blockEntity, @Nullable Entity entity, ItemStack tool
     ) {
         if (level instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(state, (ServerLevel)level, pos, blockEntity, entity, tool).forEach(p_49944_ -> popResource(level, pos, p_49944_));
-            state.spawnAfterBreak((ServerLevel)level, pos, tool, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) level, pos, state, blockEntity, captured, entity, tool);
         }
     }
 
@@ -326,19 +_,26 @@
     }
 
     private static void popResource(Level level, Supplier<ItemEntity> itemEntitySupplier, ItemStack stack) {
-        if (!level.isClientSide && !stack.isEmpty() && level.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
+        if (!level.isClientSide && !stack.isEmpty() && level.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS) && !level.restoringBlockSnapshots) {
             ItemEntity itementity = itemEntitySupplier.get();
             itementity.setDefaultPickUpDelay();
-            level.addFreshEntity(itementity);
+            // Neo: Add drops to the captured list if capturing is enabled.
+            if (capturedDrops != null) {
+                capturedDrops.add(itementity);
+            }
+            else {
+                level.addFreshEntity(itementity);
+            }
         }
     }
 
     public void popExperience(ServerLevel level, BlockPos pos, int amount) {
-        if (level.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
+        if (level.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS) && !level.restoringBlockSnapshots) {
             ExperienceOrb.award(level, Vec3.atCenterOf(pos), amount);
         }
     }
 
+    @Deprecated //Forge: Use more sensitive version
     public float getExplosionResistance() {
         return this.explosionResistance;
     }
@@ -385,8 +_,10 @@
 
     public void updateEntityAfterFallOn(BlockGetter level, Entity entity) {
         entity.setDeltaMovement(entity.getDeltaMovement().multiply(1.0, 0.0, 1.0));
+        entity.setDeltaMovement(entity.getDeltaMovement().multiply(1.0D, 0.0D, 1.0D));
     }
 
+    @Deprecated //Forge: Use more sensitive version
     public ItemStack getCloneItemStack(LevelReader level, BlockPos pos, BlockState state) {
         return new ItemStack(this);
     }
@@ -420,6 +_,7 @@
     public void handlePrecipitation(BlockState state, Level level, BlockPos pos, Biome.Precipitation precipitation) {
     }
 
+    @Deprecated //Forge: Use more sensitive version
     public boolean dropFromExplosion(Explosion explosion) {
         return true;
     }
@@ -485,6 +_,62 @@
         return this.stateDefinition.getPossibleStates().stream().collect(ImmutableMap.toImmutableMap(Function.identity(), shapeGetter));
     }
 
+    /**
+     * Neo: Short-lived holder of dropped item entities. Used mainly for Neo hooks and event logic.
+     * <p>
+     * When not null, records all item entities from {@link #popResource(Level, Supplier, ItemStack)} instead of adding them to the world.
+     */
+    @Nullable
+    private static List<ItemEntity> capturedDrops = null;
+
+    /**
+     * Initializes {@link #capturedDrops}, starting the drop capture process.
+     * <p>
+     * Must only be called on the server thread.
+     */
+    private static void beginCapturingDrops() {
+        capturedDrops = new java.util.ArrayList<>();
+    }
+
+    /**
+     * Ends the drop capture process by setting {@link #capturedDrops} to null and returning the old list.
+     * <p>
+     * Must only be called on the server thread.
+     */
+    private static List<ItemEntity> stopCapturingDrops() {
+        List<ItemEntity> drops = capturedDrops;
+        capturedDrops = null;
+        return drops;
+    }
+
+    // Neo: Client rendering for Blocks
+    private Object renderProperties;
+
+    /**
+     * Neo: DO NOT CALL, IT WILL DISAPPEAR IN THE FUTURE
+     * TODO: Replace this with a better solution
+     * Call {@link net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions#of(Block)}  instead
+     */
+    public Object getRenderPropertiesInternal() {
+        return renderProperties;
+    }
+
+    // Neo: Minecraft instance isn't available in datagen, so don't call initializeClient if in datagen
+    private void initClient() {
+        if (net.neoforged.fml.loading.FMLEnvironment.dist == net.neoforged.api.distmarker.Dist.CLIENT && !net.neoforged.neoforge.data.loading.DatagenModLoader.isRunningDataGen()) {
+            initializeClient(properties -> {
+                if (properties == this)
+                    throw new IllegalStateException("Don't extend IBlockRenderProperties in your block, use an anonymous class instead.");
+                this.renderProperties = properties;
+            });
+        }
+    }
+
+    // Neo: Allowing mods to define client behavior for their Blocks
+    public void initializeClient(java.util.function.Consumer<net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions> consumer) {
+    }
+
+    /** @deprecated */
     @Deprecated
     public Holder.Reference<Block> builtInRegistryHolder() {
         return this.builtInRegistryHolder;
