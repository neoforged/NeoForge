--- a/net/minecraft/world/level/block/Block.java
+++ b/net/minecraft/world/level/block/Block.java
@@ -61,11 +_,11 @@
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.slf4j.Logger;
 
-public class Block extends BlockBehaviour implements ItemLike {
+public class Block extends BlockBehaviour implements ItemLike, net.neoforged.neoforge.common.extensions.IBlockExtension {
     public static final MapCodec<Block> CODEC = simpleCodec(Block::new);
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder = BuiltInRegistries.BLOCK.createIntrusiveHolder(this);
-    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
+    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = net.neoforged.neoforge.registries.GameData.getBlockStateIDMap();
     private static final LoadingCache<VoxelShape, Boolean> SHAPE_FULL_BLOCK_CACHE = CacheBuilder.newBuilder()
         .maximumSize(512L)
         .weakKeys()
@@ -186,7 +_,7 @@
         this.createBlockStateDefinition(builder);
         this.stateDefinition = builder.create(Block::defaultBlockState, BlockState::new);
         this.registerDefaultState(this.stateDefinition.any());
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
+        if (SharedConstants.IS_RUNNING_IN_IDE && false) {
             String s = this.getClass().getSimpleName();
             if (!s.endsWith("Block")) {
                 LOGGER.error("Block classes should end with Block and {} doesn't.", s);
@@ -208,6 +_,8 @@
         BlockState blockstate = p_152446_.getBlockState(p_152449_);
         if (p_152445_.skipRendering(blockstate, p_152448_)) {
             return false;
+        } else if (blockstate.hidesNeighborFace(p_152446_, p_152449_, p_152445_, p_152448_.getOpposite()) && p_152445_.supportsExternalFaceHiding()) {
+            return false;
         } else if (blockstate.canOcclude()) {
             Block.BlockStatePairKey block$blockstatepairkey = new Block.BlockStatePairKey(p_152445_, blockstate, p_152448_);
             Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey> object2bytelinkedopenhashmap = OCCLUSION_CACHE.get();
@@ -281,24 +_,30 @@
 
     public static void dropResources(BlockState p_49951_, Level p_49952_, BlockPos p_49953_) {
         if (p_49952_ instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(p_49951_, (ServerLevel)p_49952_, p_49953_, null).forEach(p_152406_ -> popResource(p_49952_, p_49953_, p_152406_));
-            p_49951_.spawnAfterBreak((ServerLevel)p_49952_, p_49953_, ItemStack.EMPTY, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) p_49952_, p_49953_, p_49951_, null, captured, null, ItemStack.EMPTY);
         }
     }
 
     public static void dropResources(BlockState p_49893_, LevelAccessor p_49894_, BlockPos p_49895_, @Nullable BlockEntity p_49896_) {
         if (p_49894_ instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(p_49893_, (ServerLevel)p_49894_, p_49895_, p_49896_).forEach(p_49859_ -> popResource((ServerLevel)p_49894_, p_49895_, p_49859_));
-            p_49893_.spawnAfterBreak((ServerLevel)p_49894_, p_49895_, ItemStack.EMPTY, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) p_49894_, p_49895_, p_49893_, p_49896_, captured, null, ItemStack.EMPTY);
         }
     }
 
     public static void dropResources(
-        BlockState p_49882_, Level p_49883_, BlockPos p_49884_, @Nullable BlockEntity p_49885_, @Nullable Entity p_49886_, ItemStack p_49887_
+            BlockState p_49882_, Level p_49883_, BlockPos p_49884_, @Nullable BlockEntity p_49885_, @Nullable Entity p_49886_, ItemStack p_49887_
     ) {
         if (p_49883_ instanceof ServerLevel) {
+            beginCapturingDrops();
             getDrops(p_49882_, (ServerLevel)p_49883_, p_49884_, p_49885_, p_49886_, p_49887_).forEach(p_49944_ -> popResource(p_49883_, p_49884_, p_49944_));
-            p_49882_.spawnAfterBreak((ServerLevel)p_49883_, p_49884_, p_49887_, true);
+            List<ItemEntity> captured = stopCapturingDrops();
+            net.neoforged.neoforge.common.CommonHooks.handleBlockDrops((ServerLevel) p_49883_, p_49884_, p_49882_, p_49885_, captured, p_49886_, p_49887_);
         }
     }
 
@@ -326,19 +_,26 @@
     }
 
     private static void popResource(Level p_152441_, Supplier<ItemEntity> p_152442_, ItemStack p_152443_) {
-        if (!p_152441_.isClientSide && !p_152443_.isEmpty() && p_152441_.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
+        if (!p_152441_.isClientSide && !p_152443_.isEmpty() && p_152441_.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS) && !p_152441_.restoringBlockSnapshots) {
             ItemEntity itementity = p_152442_.get();
             itementity.setDefaultPickUpDelay();
-            p_152441_.addFreshEntity(itementity);
+            // Neo: Add drops to the captured list if capturing is enabled.
+            if (capturedDrops != null) {
+                capturedDrops.add(itementity);
+            }
+            else {
+                p_152441_.addFreshEntity(itementity);
+            }
         }
     }
 
     public void popExperience(ServerLevel p_49806_, BlockPos p_49807_, int p_49808_) {
-        if (p_49806_.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
+        if (p_49806_.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS) && !p_49806_.restoringBlockSnapshots) {
             ExperienceOrb.award(p_49806_, Vec3.atCenterOf(p_49807_), p_49808_);
         }
     }
 
+    @Deprecated //Forge: Use more sensitive version
     public float getExplosionResistance() {
         return this.explosionResistance;
     }
@@ -385,8 +_,10 @@
 
     public void updateEntityAfterFallOn(BlockGetter p_49821_, Entity p_49822_) {
         p_49822_.setDeltaMovement(p_49822_.getDeltaMovement().multiply(1.0, 0.0, 1.0));
+        p_49822_.setDeltaMovement(p_49822_.getDeltaMovement().multiply(1.0D, 0.0D, 1.0D));
     }
 
+    @Deprecated //Forge: Use more sensitive version
     public ItemStack getCloneItemStack(LevelReader p_304395_, BlockPos p_49824_, BlockState p_49825_) {
         return new ItemStack(this);
     }
@@ -420,6 +_,7 @@
     public void handlePrecipitation(BlockState p_152450_, Level p_152451_, BlockPos p_152452_, Biome.Precipitation p_152453_) {
     }
 
+    @Deprecated //Forge: Use more sensitive version
     public boolean dropFromExplosion(Explosion p_49826_) {
         return true;
     }
@@ -485,6 +_,43 @@
         return this.stateDefinition.getPossibleStates().stream().collect(ImmutableMap.toImmutableMap(Function.identity(), p_152459_));
     }
 
+    /**
+     * Neo: Short-lived holder of dropped item entities. Used mainly for Neo hooks and event logic.
+     * <p>
+     * When not null, records all item entities from {@link #popResource(Level, Supplier, ItemStack)} instead of adding them to the world.
+     */
+    @Nullable
+    private static List<ItemEntity> capturedDrops = null;
+
+    /**
+     * Initializes {@link #capturedDrops}, starting the drop capture process.
+     * <p>
+     * Must only be called on the server thread.
+     */
+    private static void beginCapturingDrops() {
+        capturedDrops = new java.util.ArrayList<>();
+    }
+
+    /**
+     * Ends the drop capture process by setting {@link #capturedDrops} to null and returning the old list.
+     * <p>
+     * Must only be called on the server thread.
+     */
+    private static List<ItemEntity> stopCapturingDrops() {
+        List<ItemEntity> drops = capturedDrops;
+        capturedDrops = null;
+        return drops;
+    }
+
+    /**
+     * Neo: Allowing mods to define client behavior for their Blocks
+     * @deprecated Use {@link net.neoforged.neoforge.client.extensions.common.RegisterClientExtensionsEvent} instead
+     */
+    @Deprecated(forRemoval = true, since = "1.21")
+    public void initializeClient(java.util.function.Consumer<net.neoforged.neoforge.client.extensions.common.IClientBlockExtensions> consumer) {
+    }
+
+    /** @deprecated */
     @Deprecated
     public Holder.Reference<Block> builtInRegistryHolder() {
         return this.builtInRegistryHolder;
