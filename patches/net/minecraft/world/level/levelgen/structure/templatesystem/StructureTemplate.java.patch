--- a/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java
+++ b/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java
@@ -219,6 +_,10 @@
         return transform(pos, decorator.getMirror(), decorator.getRotation(), decorator.getRotationPivot());
     }
 
+    public static Vec3 transformedVec3d(StructurePlaceSettings placementIn, Vec3 pos) {
+        return transform(pos, placementIn.getMirror(), placementIn.getRotation(), placementIn.getRotationPivot());
+    }
+
     public boolean placeInWorld(
         ServerLevelAccessor serverLevel, BlockPos offset, BlockPos pos, StructurePlaceSettings settings, RandomSource random, int flags
     ) {
@@ -242,7 +_,7 @@
                 int j1 = Integer.MIN_VALUE;
 
                 for (StructureTemplate.StructureBlockInfo structuretemplate$structureblockinfo : processBlockInfos(
-                    serverLevel, offset, pos, settings, list
+                    serverLevel, offset, pos, settings, list, this
                 )) {
                     BlockPos blockpos = structuretemplate$structureblockinfo.pos;
                     if (boundingbox == null || boundingbox.isInside(blockpos)) {
@@ -355,15 +_,7 @@
                 }
 
                 if (!settings.isIgnoreEntities()) {
-                    this.placeEntities(
-                        serverLevel,
-                        offset,
-                        settings.getMirror(),
-                        settings.getRotation(),
-                        settings.getRotationPivot(),
-                        boundingbox,
-                        settings.shouldFinalizeEntities()
-                    );
+                    this.addEntitiesToWorld(serverLevel, offset, settings);
                 }
 
                 return true;
@@ -402,12 +_,20 @@
     }
 
     public static List<StructureTemplate.StructureBlockInfo> processBlockInfos(
+    /**
+     * @deprecated Forge: Use {@link #processBlockInfos(ServerLevelAccessor, BlockPos, BlockPos, StructurePlaceSettings, List, StructureTemplate)} instead.
+     */
+    @Deprecated
         ServerLevelAccessor serverLevel,
         BlockPos offset,
         BlockPos pos,
         StructurePlaceSettings settings,
         List<StructureTemplate.StructureBlockInfo> blockInfos
     ) {
+        return processBlockInfos(serverLevel, offset, pos, settings, blockInfos, null);
+    }
+
+    public static List<StructureTemplate.StructureBlockInfo> processBlockInfos(ServerLevelAccessor serverLevel, BlockPos offset, BlockPos pos, StructurePlaceSettings settings, List<StructureTemplate.StructureBlockInfo> blockInfos, @Nullable StructureTemplate template) {
         List<StructureTemplate.StructureBlockInfo> list = new ArrayList<>();
         List<StructureTemplate.StructureBlockInfo> list1 = new ArrayList<>();
 
@@ -422,7 +_,7 @@
 
             while (structuretemplate$structureblockinfo1 != null && iterator.hasNext()) {
                 structuretemplate$structureblockinfo1 = iterator.next()
-                    .processBlock(serverLevel, offset, pos, structuretemplate$structureblockinfo, structuretemplate$structureblockinfo1, settings);
+                    .process(serverLevel, offset, pos, structuretemplate$structureblockinfo, structuretemplate$structureblockinfo1, settings, template);
             }
 
             if (structuretemplate$structureblockinfo1 != null) {
@@ -438,21 +_,29 @@
         return list1;
     }
 
-    private void placeEntities(
-        ServerLevelAccessor serverLevel,
-        BlockPos pos,
-        Mirror mirror,
-        Rotation rotation,
-        BlockPos offset,
-        @Nullable BoundingBox boundingBox,
-        boolean withEntities
-    ) {
-        for (StructureTemplate.StructureEntityInfo structuretemplate$structureentityinfo : this.entityInfoList) {
-            BlockPos blockpos = transform(structuretemplate$structureentityinfo.blockPos, mirror, rotation, offset).offset(pos);
-            if (boundingBox == null || boundingBox.isInside(blockpos)) {
+    public static List<StructureTemplate.StructureEntityInfo> processEntityInfos(@Nullable StructureTemplate template, LevelAccessor p_215387_0_, BlockPos p_215387_1_, StructurePlaceSettings p_215387_2_, List<StructureTemplate.StructureEntityInfo> p_215387_3_) {
+        List<StructureTemplate.StructureEntityInfo> list = Lists.newArrayList();
+        for(StructureTemplate.StructureEntityInfo entityInfo : p_215387_3_) {
+            Vec3 pos = transformedVec3d(p_215387_2_, entityInfo.pos).add(Vec3.atLowerCornerOf(p_215387_1_));
+            BlockPos blockpos = calculateRelativePosition(p_215387_2_, entityInfo.blockPos).offset(p_215387_1_);
+            StructureTemplate.StructureEntityInfo info = new StructureTemplate.StructureEntityInfo(pos, blockpos, entityInfo.nbt);
+            for (StructureProcessor proc : p_215387_2_.getProcessors()) {
+                info = proc.processEntity(p_215387_0_, p_215387_1_, entityInfo, info, p_215387_2_, template);
+                if (info == null)
+                    break;
+            }
+            if (info != null)
+                list.add(info);
+        }
+        return list;
+    }
+
+    private void addEntitiesToWorld(ServerLevelAccessor serverLevel, BlockPos pos, StructurePlaceSettings placementIn) {
+        for(StructureTemplate.StructureEntityInfo structuretemplate$structureentityinfo : processEntityInfos(this, serverLevel, pos, placementIn, this.entityInfoList)) {
+            BlockPos blockpos = structuretemplate$structureentityinfo.blockPos; // FORGE: Position will have already been transformed by processEntityInfos
+            if (placementIn.getBoundingBox() == null || placementIn.getBoundingBox().isInside(blockpos)) {
                 CompoundTag compoundtag = structuretemplate$structureentityinfo.nbt.copy();
-                Vec3 vec3 = transform(structuretemplate$structureentityinfo.pos, mirror, rotation, offset);
-                Vec3 vec31 = vec3.add((double)pos.getX(), (double)pos.getY(), (double)pos.getZ());
+                Vec3 vec31 = structuretemplate$structureentityinfo.pos; // FORGE: Position will have already been transformed by processEntityInfos
                 ListTag listtag = new ListTag();
                 listtag.add(DoubleTag.valueOf(vec31.x));
                 listtag.add(DoubleTag.valueOf(vec31.y));
@@ -460,10 +_,10 @@
                 compoundtag.put("Pos", listtag);
                 compoundtag.remove("UUID");
                 createEntityIgnoreException(serverLevel, compoundtag).ifPresent(p_275190_ -> {
-                    float f = p_275190_.rotate(rotation);
-                    f += p_275190_.mirror(mirror) - p_275190_.getYRot();
+                    float f = p_275190_.rotate(placementIn.getRotation());
+                    f += p_275190_.mirror(placementIn.getMirror()) - p_275190_.getYRot();
                     p_275190_.moveTo(vec31.x, vec31.y, vec31.z, f, p_275190_.getXRot());
-                    if (withEntities && p_275190_ instanceof Mob) {
+                    if (placementIn.shouldFinalizeEntities() && p_275190_ instanceof Mob) {
                         ((Mob)p_275190_).finalizeSpawn(serverLevel, serverLevel.getCurrentDifficultyAt(BlockPos.containing(vec31)), MobSpawnType.STRUCTURE, null);
                     }
 
@@ -777,7 +_,7 @@
 
     public static final class Palette {
         private final List<StructureTemplate.StructureBlockInfo> blocks;
-        private final Map<Block, List<StructureTemplate.StructureBlockInfo>> cache = Maps.newHashMap();
+        private final Map<Block, List<StructureTemplate.StructureBlockInfo>> cache = Maps.newConcurrentMap(); // Neo: Fixes MC-271899 - Make the global StructureTemplate's palette caches now thread safe for worldgen
 
         Palette(List<StructureTemplate.StructureBlockInfo> blocks) {
             this.blocks = blocks;
