--- a/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -57,7 +_,7 @@
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.slf4j.Logger;
 
-public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiomeSource, LightChunk, StructureAccess {
+public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiomeSource, LightChunk, StructureAccess, net.neoforged.neoforge.attachment.IAttachmentHolderExtension<ChunkAccess> {
     public static final int NO_FILLED_SECTION = -1;
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final LongSet EMPTY_REFERENCE_SET = new LongOpenHashSet();
@@ -315,10 +_,19 @@
 
     @Override
     public final void findBlockLightSources(BiConsumer<BlockPos, BlockState> p_285269_) {
-        this.findBlocks(p_284897_ -> p_284897_.getLightEmission() != 0, p_285269_);
+        this.findBlocks(p_284897_ -> p_284897_.hasDynamicLightEmission() || p_284897_.getLightEmission(net.minecraft.world.level.EmptyBlockGetter.INSTANCE, BlockPos.ZERO) != 0, (p_284897_, pos) -> p_284897_.getLightEmission(this, pos) != 0, p_285269_);
     }
 
     public void findBlocks(Predicate<BlockState> p_285343_, BiConsumer<BlockPos, BlockState> p_285030_) {
+        findBlocks(p_285343_, (state, pos) -> p_285343_.test(state), p_285030_);
+    }
+
+    @Deprecated(forRemoval = true)
+    public void findBlocks(java.util.function.BiPredicate<BlockState, BlockPos> p_285343_, BiConsumer<BlockPos, BlockState> p_285030_) {
+        findBlocks(state -> p_285343_.test(state, BlockPos.ZERO), p_285343_, p_285030_);
+    }
+
+    public void findBlocks(Predicate<BlockState> p_285343_, java.util.function.BiPredicate<BlockState, BlockPos> fineFilter, BiConsumer<BlockPos, BlockState> p_285030_) {
         BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos();
 
         for (int i = this.getMinSection(); i < this.getMaxSection(); i++) {
@@ -330,8 +_,9 @@
                     for (int k = 0; k < 16; k++) {
                         for (int l = 0; l < 16; l++) {
                             BlockState blockstate = levelchunksection.getBlockState(l, j, k);
-                            if (p_285343_.test(blockstate)) {
-                                p_285030_.accept(blockpos$mutableblockpos.setWithOffset(blockpos, l, j, k), blockstate);
+                            blockpos$mutableblockpos.setWithOffset(blockpos, l, j, k);
+                            if (fineFilter.test(blockstate, blockpos$mutableblockpos)) {
+                                p_285030_.accept(blockpos$mutableblockpos, blockstate);
                             }
                         }
                     }
@@ -476,4 +_,23 @@
 
     public static record TicksToSave(SerializableTickContainer<Block> blocks, SerializableTickContainer<Fluid> fluids) {
     }
+
+    // FORGE START
+    private final net.neoforged.neoforge.attachment.AttachmentHolder<ChunkAccess> attachmentHolder = new net.neoforged.neoforge.attachment.AttachmentHolder<>(this);
+    public net.neoforged.neoforge.attachment.AttachmentHolder<ChunkAccess> dataAttachments() { return attachmentHolder; }
+
+    @Override
+    public <T> T setData(net.neoforged.neoforge.attachment.AttachmentType<T> type, T data) {
+        setUnsaved(true);
+        return net.neoforged.neoforge.attachment.IAttachmentHolderExtension.super.setData(type, data);
+    }
+
+    @Override
+    public <T> T removeData(net.neoforged.neoforge.attachment.AttachmentType<T> type) {
+        setUnsaved(true);
+        return net.neoforged.neoforge.attachment.IAttachmentHolderExtension.super.removeData(type);
+    }
+
+    @Nullable
+    public net.minecraft.world.level.Level getLevel() { return null; }
 }
