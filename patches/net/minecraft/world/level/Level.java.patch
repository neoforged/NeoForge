--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -76,7 +_,7 @@
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.Scoreboard;
 
-public abstract class Level implements LevelAccessor, AutoCloseable {
+public abstract class Level extends net.neoforged.neoforge.attachment.AttachmentHolder implements LevelAccessor, AutoCloseable, net.neoforged.neoforge.common.extensions.ILevelExtension {
     public static final Codec<ResourceKey<Level>> RESOURCE_KEY_CODEC = ResourceKey.codec(Registries.DIMENSION);
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("overworld"));
     public static final ResourceKey<Level> NETHER = ResourceKey.create(Registries.DIMENSION, ResourceLocation.withDefaultNamespace("the_nether"));
@@ -114,6 +_,11 @@
     private final RegistryAccess registryAccess;
     private final DamageSources damageSources;
     private long subTickCount;
+    public boolean restoringBlockSnapshots = false;
+    public boolean captureBlockSnapshots = false;
+    public java.util.ArrayList<net.neoforged.neoforge.common.util.BlockSnapshot> capturedBlockSnapshots = new java.util.ArrayList<>();
+    private final java.util.ArrayList<BlockEntity> freshBlockEntities = new java.util.ArrayList<>();
+    private final java.util.ArrayList<BlockEntity> pendingFreshBlockEntities = new java.util.ArrayList<>();
 
     protected Level(
         WritableLevelData levelData,
@@ -216,11 +_,40 @@
         } else {
             LevelChunk levelchunk = this.getChunkAt(pos);
             Block block = state.getBlock();
+
+            pos = pos.immutable(); // Forge - prevent mutable BlockPos leaks
+            net.neoforged.neoforge.common.util.BlockSnapshot blockSnapshot = null;
+            if (this.captureBlockSnapshots && !this.isClientSide) {
+                 blockSnapshot = net.neoforged.neoforge.common.util.BlockSnapshot.create(this.dimension, this, pos, flags);
+                 this.capturedBlockSnapshots.add(blockSnapshot);
+            }
+
+            BlockState old = getBlockState(pos);
+            int oldLight = old.getLightEmission(this, pos);
+            int oldOpacity = old.getLightBlock(this, pos);
+
             BlockState blockstate = levelchunk.setBlockState(pos, state, (flags & 64) != 0);
             if (blockstate == null) {
+                if (blockSnapshot != null) this.capturedBlockSnapshots.remove(blockSnapshot);
                 return false;
             } else {
                 BlockState blockstate1 = this.getBlockState(pos);
+
+                if (blockSnapshot == null) { // Don't notify clients or update physics while capturing blockstates
+                    this.markAndNotifyBlock(pos, levelchunk, blockstate, state, flags, recursionLeft);
+                }
+
+                return true;
+            }
+        }
+    }
+
+    // Split off from original setBlockState(BlockPos, BlockState, int, int) method in order to directly send client and physic updates
+    public void markAndNotifyBlock(BlockPos pos, @Nullable LevelChunk levelchunk, BlockState blockstate, BlockState state, int flags, int recursionLeft) {
+        Block block = state.getBlock();
+        BlockState blockstate1 = getBlockState(pos);
+        {
+            {
                 if (blockstate1 == state) {
                     if (blockstate != blockstate1) {
                         this.setBlocksDirty(pos, blockstate, blockstate1);
@@ -247,9 +_,8 @@
                     }
 
                     this.onBlockStateChange(pos, blockstate, blockstate1);
+                    state.onBlockStateChange(this, pos, blockstate);
                 }
-
-                return true;
             }
         }
     }
@@ -301,6 +_,7 @@
     }
 
     public void updateNeighborsAt(BlockPos pos, Block block) {
+        net.neoforged.neoforge.event.EventHooks.onNeighborNotify(this, pos, this.getBlockState(pos), java.util.EnumSet.allOf(Direction.class), false).isCanceled();
     }
 
     public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block blockType, Direction skipSide) {
@@ -489,10 +_,26 @@
         (this.tickingBlockEntities ? this.pendingBlockEntityTickers : this.blockEntityTickers).add(ticker);
     }
 
+    public void addFreshBlockEntities(java.util.Collection<BlockEntity> beList) {
+        if (this.tickingBlockEntities) {
+            this.pendingFreshBlockEntities.addAll(beList);
+        } else {
+            this.freshBlockEntities.addAll(beList);
+        }
+    }
+
     protected void tickBlockEntities() {
         ProfilerFiller profilerfiller = this.getProfiler();
         profilerfiller.push("blockEntities");
+        if (!this.pendingFreshBlockEntities.isEmpty()) {
+            this.freshBlockEntities.addAll(this.pendingFreshBlockEntities);
+            this.pendingFreshBlockEntities.clear();
+        }
         this.tickingBlockEntities = true;
+        if (!this.freshBlockEntities.isEmpty()) {
+            this.freshBlockEntities.forEach(BlockEntity::onLoad);
+            this.freshBlockEntities.clear();
+        }
         if (!this.pendingBlockEntityTickers.isEmpty()) {
             this.blockEntityTickers.addAll(this.pendingBlockEntityTickers);
             this.pendingBlockEntityTickers.clear();
@@ -516,12 +_,19 @@
 
     public <T extends Entity> void guardEntityTick(Consumer<T> consumerEntity, T entity) {
         try {
+            net.neoforged.neoforge.server.timings.TimeTracker.ENTITY_UPDATE.trackStart(entity);
             consumerEntity.accept(entity);
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Ticking entity");
             CrashReportCategory crashreportcategory = crashreport.addCategory("Entity being ticked");
             entity.fillCrashReportCategory(crashreportcategory);
+            if (net.neoforged.neoforge.common.NeoForgeConfig.SERVER.removeErroringEntities.get()) {
+                com.mojang.logging.LogUtils.getLogger().error("{}", crashreport.getFriendlyReport(net.minecraft.ReportType.CRASH));
+                entity.discard();
+            } else
             throw new ReportedException(crashreport);
+        } finally {
+            net.neoforged.neoforge.server.timings.TimeTracker.ENTITY_UPDATE.trackEnd(entity);
         }
     }
 
@@ -670,7 +_,7 @@
         Explosion.BlockInteraction explosion$blockinteraction = switch (explosionInteraction) {
             case NONE -> Explosion.BlockInteraction.KEEP;
             case BLOCK -> this.getDestroyType(GameRules.RULE_BLOCK_EXPLOSION_DROP_DECAY);
-            case MOB -> this.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)
+            case MOB -> net.neoforged.neoforge.event.EventHooks.canEntityGrief(this, source)
             ? this.getDestroyType(GameRules.RULE_MOB_EXPLOSION_DROP_DECAY)
             : Explosion.BlockInteraction.KEEP;
             case TNT -> this.getDestroyType(GameRules.RULE_TNT_EXPLOSION_DROP_DECAY);
@@ -691,6 +_,7 @@
             largeExplosionParticles,
             explosionSound
         );
+        if (net.neoforged.neoforge.event.EventHooks.onExplosionStart(this, explosion)) return explosion;
         explosion.explode();
         explosion.finalizeExplosion(spawnParticles);
         return explosion;
@@ -725,6 +_,7 @@
         if (!this.isOutsideBuildHeight(pos)) {
             this.getChunkAt(pos).removeBlockEntity(pos);
         }
+        this.updateNeighbourForOutputSignal(pos, getBlockState(pos).getBlock()); //Notify neighbors of changes
     }
 
     public boolean isLoaded(BlockPos pos) {
@@ -803,6 +_,7 @@
                 list.add(p_151522_);
             }
 
+            if (false)
             if (p_151522_ instanceof EnderDragon) {
                 for (EnderDragonPart enderdragonpart : ((EnderDragon)p_151522_).getSubEntities()) {
                     if (p_151522_ != entity && predicate.test(enderdragonpart)) {
@@ -811,6 +_,11 @@
                 }
             }
         });
+        for (net.neoforged.neoforge.entity.PartEntity<?> p : this.getPartEntities()) {
+            if (p != entity && p.getBoundingBox().intersects(boundingBox) && predicate.test(p)) {
+                list.add(p);
+            }
+        }
         return list;
     }
 
@@ -837,6 +_,8 @@
                 }
             }
 
+
+            if (false)
             if (p_261454_ instanceof EnderDragon enderdragon) {
                 for (EnderDragonPart enderdragonpart : enderdragon.getSubEntities()) {
                     T t = entityTypeTest.tryCast(enderdragonpart);
@@ -851,6 +_,15 @@
 
             return AbortableIterationConsumer.Continuation.CONTINUE;
         });
+        for (net.neoforged.neoforge.entity.PartEntity<?> p : this.getPartEntities()) {
+            T t = entityTypeTest.tryCast(p);
+            if (t != null && t.getBoundingBox().intersects(bounds) && predicate.test(t)) {
+                output.add(t);
+                if (output.size() >= maxResults) {
+                    break;
+                }
+            }
+        }
     }
 
     @Nullable
@@ -979,16 +_,15 @@
     public abstract Scoreboard getScoreboard();
 
     public void updateNeighbourForOutputSignal(BlockPos pos, Block block) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
+        for(Direction direction : Direction.values()) {
             BlockPos blockpos = pos.relative(direction);
             if (this.hasChunkAt(blockpos)) {
                 BlockState blockstate = this.getBlockState(blockpos);
-                if (blockstate.is(Blocks.COMPARATOR)) {
-                    this.neighborChanged(blockstate, blockpos, block, pos, false);
-                } else if (blockstate.isRedstoneConductor(this, blockpos)) {
+                blockstate.onNeighborChange(this, blockpos, pos);
+                if (blockstate.isRedstoneConductor(this, blockpos)) {
                     blockpos = blockpos.relative(direction);
                     blockstate = this.getBlockState(blockpos);
-                    if (blockstate.is(Blocks.COMPARATOR)) {
+                    if (blockstate.getWeakChanges(this, blockpos)) {
                         this.neighborChanged(blockstate, blockpos, block, pos, false);
                     }
                 }
@@ -1076,6 +_,18 @@
     @Override
     public BiomeManager getBiomeManager() {
         return this.biomeManager;
+    }
+
+    private double maxEntityRadius = 2.0D;
+    @Override
+    public double getMaxEntityRadius() {
+        return maxEntityRadius;
+    }
+    @Override
+    public double increaseMaxEntityRadius(double value) {
+        if (value > maxEntityRadius)
+            maxEntityRadius = value;
+        return maxEntityRadius;
     }
 
     public final boolean isDebug() {
