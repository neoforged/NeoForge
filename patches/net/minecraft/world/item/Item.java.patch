--- a/net/minecraft/world/item/Item.java
+++ b/net/minecraft/world/item/Item.java
@@ -56,9 +_,9 @@
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
 
-public class Item implements FeatureElement, ItemLike {
+public class Item implements FeatureElement, ItemLike, net.neoforged.neoforge.common.extensions.IItemExtension {
     private static final Logger LOGGER = LogUtils.getLogger();
-    public static final Map<Block, Item> BY_BLOCK = Maps.newHashMap();
+    public static final Map<Block, Item> BY_BLOCK = net.neoforged.neoforge.registries.GameData.getBlockItemMap();
     public static final ResourceLocation BASE_ATTACK_DAMAGE_ID = ResourceLocation.withDefaultNamespace("base_attack_damage");
     public static final ResourceLocation BASE_ATTACK_SPEED_ID = ResourceLocation.withDefaultNamespace("base_attack_speed");
     public static final int DEFAULT_MAX_STACK_SIZE = 64;
@@ -89,12 +_,14 @@
         this.components = properties.buildAndValidateComponents();
         this.craftingRemainingItem = properties.craftingRemainingItem;
         this.requiredFeatures = properties.requiredFeatures;
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
+        if (SharedConstants.IS_RUNNING_IN_IDE && false) {
             String s = this.getClass().getSimpleName();
             if (!s.endsWith("Item")) {
                 LOGGER.error("Item classes should end with Item and {} doesn't.", s);
             }
         }
+        this.canRepair = properties.canRepair;
+        initClient();
     }
 
     @Deprecated
@@ -106,6 +_,15 @@
         return this.components;
     }
 
+    /** @deprecated Neo: do not use, use {@link net.neoforged.neoforge.event.ModifyDefaultComponentsEvent the event} instead */
+    @org.jetbrains.annotations.ApiStatus.Internal @Deprecated
+    public void modifyDefaultComponentsFrom(net.minecraft.core.component.DataComponentPatch patch) {
+        if (!net.neoforged.neoforge.internal.RegistrationEvents.canModifyComponents()) throw new IllegalStateException("Default components cannot be modified now!");
+        var builder = DataComponentMap.builder().addAll(components);
+        patch.entrySet().forEach(entry -> builder.set((DataComponentType)entry.getKey(), entry.getValue().orElse(null)));
+        components = Properties.COMPONENT_INTERNER.intern(Properties.validateComponents(builder.build()));
+    }
+
     public int getDefaultMaxStackSize() {
         return this.components.getOrDefault(DataComponents.MAX_STACK_SIZE, 1);
     }
@@ -113,6 +_,8 @@
     public void onUseTick(Level level, LivingEntity livingEntity, ItemStack stack, int remainingUseDuration) {
     }
 
+    /** @deprecated Forge: {@link net.neoforged.neoforge.common.extensions.IItemExtension#onDestroyed(ItemEntity, DamageSource) Use damage source sensitive version} */
+    @Deprecated
     public void onDestroyed(ItemEntity itemEntity) {
     }
 
@@ -139,7 +_,7 @@
 
     public InteractionResultHolder<ItemStack> use(Level level, Player player, InteractionHand usedHand) {
         ItemStack itemstack = player.getItemInHand(usedHand);
-        FoodProperties foodproperties = itemstack.get(DataComponents.FOOD);
+        FoodProperties foodproperties = itemstack.getFoodProperties(player);
         if (foodproperties != null) {
             if (player.canEat(foodproperties.canAlwaysEat())) {
                 player.startUsingItem(usedHand);
@@ -153,7 +_,7 @@
     }
 
     public ItemStack finishUsingItem(ItemStack stack, Level level, LivingEntity livingEntity) {
-        FoodProperties foodproperties = stack.get(DataComponents.FOOD);
+        FoodProperties foodproperties = stack.getFoodProperties(livingEntity);
         return foodproperties != null ? livingEntity.eat(level, stack, foodproperties) : stack;
     }
 
@@ -162,12 +_,13 @@
     }
 
     public int getBarWidth(ItemStack stack) {
-        return Mth.clamp(Math.round(13.0F - (float)stack.getDamageValue() * 13.0F / (float)stack.getMaxDamage()), 0, 13);
+        return Math.round(13.0F - (float)stack.getDamageValue() * 13.0F / (float)this.getMaxDamage(stack));
     }
 
     public int getBarColor(ItemStack stack) {
         int i = stack.getMaxDamage();
-        float f = Math.max(0.0F, ((float)i - (float)stack.getDamageValue()) / (float)i);
+        float stackMaxDamage = this.getMaxDamage(stack);
+        float f = Math.max(0.0F, (stackMaxDamage - (float)stack.getDamageValue()) / stackMaxDamage);
         return Mth.hsvToRgb(f / 3.0F, 1.0F, 1.0F);
     }
 
@@ -240,10 +_,12 @@
     }
 
     @Nullable
+    @Deprecated // Use ItemStack sensitive version.
     public final Item getCraftingRemainingItem() {
         return this.craftingRemainingItem;
     }
 
+    @Deprecated // Use ItemStack sensitive version.
     public boolean hasCraftingRemainingItem() {
         return this.craftingRemainingItem != null;
     }
@@ -267,7 +_,7 @@
     }
 
     public int getUseDuration(ItemStack stack, LivingEntity entity) {
-        FoodProperties foodproperties = stack.get(DataComponents.FOOD);
+        FoodProperties foodproperties = stack.getFoodProperties(null);
         return foodproperties != null ? foodproperties.eatDurationTicks() : 0;
     }
 
@@ -299,6 +_,8 @@
         return level.clip(new ClipContext(vec3, vec31, ClipContext.Block.OUTLINE, fluidMode, player));
     }
 
+    /** @deprecated Neo: Use ItemStack sensitive version. */
+    @Deprecated
     public int getEnchantmentValue() {
         return 0;
     }
@@ -307,13 +_,23 @@
         return false;
     }
 
+    /**
+     * @deprecated Neo: Use {@link Item#getDefaultAttributeModifiers(ItemStack)}
+     */
     @Deprecated
     public ItemAttributeModifiers getDefaultAttributeModifiers() {
         return ItemAttributeModifiers.EMPTY;
     }
 
+    protected final boolean canRepair;
+
+    @Override
+    public boolean isRepairable(ItemStack stack) {
+        return canRepair && isDamageable(stack);
+    }
+
     public boolean useOnRelease(ItemStack stack) {
-        return false;
+        return stack.getItem() == Items.CROSSBOW;
     }
 
     public ItemStack getDefaultInstance() {
@@ -341,13 +_,41 @@
         return this.requiredFeatures;
     }
 
-    public static class Properties {
+    // Neo: Client rendering for Items
+    private Object renderProperties;
+
+    /**
+     * Neo: DO NOT CALL, IT WILL DISAPPEAR IN THE FUTURE
+     * TODO: Replace this with a better solution
+     * Call {@link net.neoforged.neoforge.client.extensions.common.IClientItemExtensions#of(Item)} instead
+     */
+    public Object getRenderPropertiesInternal() {
+        return renderProperties;
+    }
+
+    // Neo: Minecraft instance isn't available in datagen, so don't call initializeClient if in datagen
+    private void initClient() {
+        if (net.neoforged.fml.loading.FMLEnvironment.dist == net.neoforged.api.distmarker.Dist.CLIENT && !net.neoforged.neoforge.data.loading.DatagenModLoader.isRunningDataGen()) {
+            initializeClient(properties -> {
+                if (properties == this)
+                    throw new IllegalStateException("Don't extend IItemRenderProperties in your item, use an anonymous class instead.");
+                this.renderProperties = properties;
+            });
+        }
+    }
+
+    // Neo: Allowing mods to define client behavior for their Items
+    public void initializeClient(java.util.function.Consumer<net.neoforged.neoforge.client.extensions.common.IClientItemExtensions> consumer) {
+    }
+
+    public static class Properties implements net.neoforged.neoforge.common.extensions.IItemPropertiesExtensions {
         private static final Interner<DataComponentMap> COMPONENT_INTERNER = Interners.newStrongInterner();
         @Nullable
         private DataComponentMap.Builder components;
         @Nullable
         Item craftingRemainingItem;
         FeatureFlagSet requiredFeatures = FeatureFlags.VANILLA_SET;
+        private boolean canRepair = true;
 
         public Item.Properties food(FoodProperties food) {
             return this.component(DataComponents.FOOD, food);
@@ -381,12 +_,18 @@
             return this.component(DataComponents.JUKEBOX_PLAYABLE, new JukeboxPlayable(new EitherHolder<>(song), true));
         }
 
+        public Item.Properties setNoRepair() {
+            canRepair = false;
+            return this;
+        }
+
         public Item.Properties requiredFeatures(FeatureFlag... requiredFeatures) {
             this.requiredFeatures = FeatureFlags.REGISTRY.subset(requiredFeatures);
             return this;
         }
 
         public <T> Item.Properties component(DataComponentType<T> component, T value) {
+            net.neoforged.neoforge.common.CommonHooks.validateComponent(value);
             if (this.components == null) {
                 this.components = DataComponentMap.builder().addAll(DataComponents.COMMON_ITEM_COMPONENTS);
             }
@@ -401,6 +_,10 @@
 
         DataComponentMap buildAndValidateComponents() {
             DataComponentMap datacomponentmap = this.buildComponents();
+            return validateComponents(datacomponentmap);
+        }
+
+        public static DataComponentMap validateComponents(DataComponentMap datacomponentmap) {
             if (datacomponentmap.has(DataComponents.DAMAGE) && datacomponentmap.getOrDefault(DataComponents.MAX_STACK_SIZE, 1) > 1) {
                 throw new IllegalStateException("Item cannot have both durability and be stackable");
             } else {
