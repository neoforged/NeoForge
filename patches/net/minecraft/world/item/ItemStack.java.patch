--- a/net/minecraft/world/item/ItemStack.java
+++ b/net/minecraft/world/item/ItemStack.java
@@ -92,7 +_,7 @@
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.slf4j.Logger;
 
-public final class ItemStack implements DataComponentHolder {
+public final class ItemStack implements DataComponentHolder, net.neoforged.neoforge.common.extensions.IItemStackExtension, net.neoforged.neoforge.common.MutableDataComponentHolder {
     public static final Codec<Holder<Item>> ITEM_NON_AIR_CODEC = BuiltInRegistries.ITEM
         .holderByNameCodec()
         .validate(
@@ -234,6 +_,10 @@
         return !this.isEmpty() ? this.components.asPatch() : DataComponentPatch.EMPTY;
     }
 
+    public boolean isComponentsPatchEmpty() {
+        return !this.isEmpty() ? this.components.isPatchEmpty() : true;
+    }
+
     public ItemStack(ItemLike item) {
         this(item, 1);
     }
@@ -339,7 +_,7 @@
     }
 
     public boolean is(Holder<Item> item) {
-        return this.getItem().builtInRegistryHolder() == item;
+        return is(item.value()); // Neo: Fix comparing for custom holders such as DeferredHolders
     }
 
     public boolean is(HolderSet<Item> item) {
@@ -351,13 +_,26 @@
     }
 
     public InteractionResult useOn(UseOnContext context) {
+        var e = net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.player.UseItemOnBlockEvent(context, net.neoforged.neoforge.event.entity.player.UseItemOnBlockEvent.UsePhase.ITEM_AFTER_BLOCK));
+        if (e.isCanceled()) return e.getCancellationResult().result();
+        if (!context.getLevel().isClientSide) return net.neoforged.neoforge.common.CommonHooks.onPlaceItemIntoWorld(context);
+        return onItemUse(context, (c) -> getItem().useOn(context));
+    }
+
+    public InteractionResult onItemUseFirst(UseOnContext context) {
+        var e = net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(new net.neoforged.neoforge.event.entity.player.UseItemOnBlockEvent(context, net.neoforged.neoforge.event.entity.player.UseItemOnBlockEvent.UsePhase.ITEM_BEFORE_BLOCK));
+        if (e.isCanceled()) return e.getCancellationResult().result();
+        return onItemUse(context, (c) -> getItem().onItemUseFirst(this, context));
+    }
+
+    private InteractionResult onItemUse(UseOnContext context, java.util.function.Function<UseOnContext, InteractionResult> callback) {
         Player player = context.getPlayer();
         BlockPos blockpos = context.getClickedPos();
         if (player != null && !player.getAbilities().mayBuild && !this.canPlaceOnBlockInAdventureMode(new BlockInWorld(context.getLevel(), blockpos, false))) {
             return InteractionResult.PASS;
         } else {
             Item item = this.getItem();
-            InteractionResult interactionresult = item.useOn(context);
+            InteractionResult interactionresult = callback.apply(context);
             if (player != null && interactionresult.indicateItemUse()) {
                 player.awardStat(Stats.ITEM_USED.get(item));
             }
@@ -399,7 +_,7 @@
     }
 
     public int getMaxStackSize() {
-        return this.getOrDefault(DataComponents.MAX_STACK_SIZE, Integer.valueOf(1));
+        return this.getItem().getMaxStackSize(this);
     }
 
     public boolean isStackable() {
@@ -411,23 +_,28 @@
     }
 
     public boolean isDamaged() {
-        return this.isDamageableItem() && this.getDamageValue() > 0;
+        return this.isDamageableItem() && getItem().isDamaged(this);
     }
 
     public int getDamageValue() {
-        return Mth.clamp(this.getOrDefault(DataComponents.DAMAGE, Integer.valueOf(0)), 0, this.getMaxDamage());
+        return this.getItem().getDamage(this);
     }
 
     public void setDamageValue(int damage) {
-        this.set(DataComponents.DAMAGE, Mth.clamp(damage, 0, this.getMaxDamage()));
+        this.getItem().setDamage(this, damage);
     }
 
     public int getMaxDamage() {
-        return this.getOrDefault(DataComponents.MAX_DAMAGE, Integer.valueOf(0));
+        return this.getItem().getMaxDamage(this);
     }
 
     public void hurtAndBreak(int damage, ServerLevel level, @Nullable ServerPlayer player, Consumer<Item> onBreak) {
+        this.hurtAndBreak(damage, level, (LivingEntity) player, onBreak);
+    }
+
+    public void hurtAndBreak(int damage, ServerLevel level, @Nullable LivingEntity player, Consumer<Item> onBreak) {
         if (this.isDamageableItem()) {
+            damage = getItem().damageItem(this, damage, player, onBreak);
             if (player == null || !player.hasInfiniteMaterials()) {
                 if (damage > 0) {
                     damage = EnchantmentHelper.processDurabilityChange(level, this, damage);
@@ -436,8 +_,8 @@
                     }
                 }
 
-                if (player != null && damage != 0) {
-                    CriteriaTriggers.ITEM_DURABILITY_CHANGED.trigger(player, this, this.getDamageValue() + damage);
+                if (player instanceof ServerPlayer sp && damage != 0) {
+                    CriteriaTriggers.ITEM_DURABILITY_CHANGED.trigger(sp, this, this.getDamageValue() + damage);
                 }
 
                 int i = this.getDamageValue() + damage;
@@ -456,7 +_,7 @@
             this.hurtAndBreak(
                 amount,
                 serverlevel,
-                entity instanceof ServerPlayer serverplayer ? serverplayer : null,
+                entity,
                 p_348383_ -> entity.onEquippedItemBroken(p_348383_, slot)
             );
         }
@@ -728,7 +_,7 @@
             return List.of();
         } else {
             List<Component> list = Lists.newArrayList();
-            MutableComponent mutablecomponent = Component.empty().append(this.getHoverName()).withStyle(this.getRarity().color());
+            MutableComponent mutablecomponent = Component.empty().append(this.getHoverName()).withStyle(this.getRarity().getStyleModifier());
             if (this.has(DataComponents.CUSTOM_NAME)) {
                 mutablecomponent.withStyle(ChatFormatting.ITALIC);
             }
@@ -784,12 +_,14 @@
                 list.add(DISABLED_ITEM_TOOLTIP);
             }
 
+            net.neoforged.neoforge.event.EventHooks.onItemTooltip(this, player, list, tooltipFlag, tooltipContext);
             return list;
         }
     }
 
     private void addAttributeTooltips(Consumer<Component> tooltipAdder, @Nullable Player player) {
         ItemAttributeModifiers itemattributemodifiers = this.getOrDefault(DataComponents.ATTRIBUTE_MODIFIERS, ItemAttributeModifiers.EMPTY);
+        // Neo: We don't need to call IItemStackExtension#getAttributeModifiers here, since it will be done in forEachModifier.
         if (itemattributemodifiers.showInTooltip()) {
             for (EquipmentSlotGroup equipmentslotgroup : EquipmentSlotGroup.values()) {
                 MutableBoolean mutableboolean = new MutableBoolean(true);
@@ -897,6 +_,17 @@
         return !this.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY).isEmpty();
     }
 
+    /**
+     * Gets all enchantments from NBT. Use {@link ItemStack#getAllEnchantments} for gameplay logic.
+     */
+    public ItemEnchantments getTagEnchantments() {
+        return getEnchantments();
+    }
+
+    /**
+     * @deprecated Neo: Use {@link #getTagEnchantments()} for NBT enchantments, or {@link #getAllEnchantments} for gameplay.
+     */
+    @Deprecated
     public ItemEnchantments getEnchantments() {
         return this.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY);
     }
@@ -922,6 +_,12 @@
     }
 
     public void forEachModifier(EquipmentSlotGroup slotGroup, BiConsumer<Holder<Attribute>, AttributeModifier> action) {
+        // Neo: Reflect real attribute modifiers when doing iteration
+        this.getAttributeModifiers().forEach(slotGroup, action);
+
+        if (false) {
+        // Start disabled vanilla code
+
         ItemAttributeModifiers itemattributemodifiers = this.getOrDefault(DataComponents.ATTRIBUTE_MODIFIERS, ItemAttributeModifiers.EMPTY);
         if (!itemattributemodifiers.modifiers().isEmpty()) {
             itemattributemodifiers.forEach(slotGroup, action);
@@ -929,10 +_,19 @@
             this.getItem().getDefaultAttributeModifiers().forEach(slotGroup, action);
         }
 
+        // end disabled vanilla code
+        }
+
         EnchantmentHelper.forEachModifier(this, slotGroup, action);
     }
 
     public void forEachModifier(EquipmentSlot equipmentSLot, BiConsumer<Holder<Attribute>, AttributeModifier> action) {
+        // Neo: Reflect real attribute modifiers when doing iteration
+        this.getAttributeModifiers().forEach(equipmentSLot, action);
+
+        if (false) {
+        // Start disabled vanilla code
+
         ItemAttributeModifiers itemattributemodifiers = this.getOrDefault(DataComponents.ATTRIBUTE_MODIFIERS, ItemAttributeModifiers.EMPTY);
         if (!itemattributemodifiers.modifiers().isEmpty()) {
             itemattributemodifiers.forEach(equipmentSLot, action);
@@ -940,6 +_,9 @@
             this.getItem().getDefaultAttributeModifiers().forEach(equipmentSLot, action);
         }
 
+        // end disabled vanilla code
+        }
+
         EnchantmentHelper.forEachModifier(this, equipmentSLot, action);
     }
 
@@ -951,7 +_,7 @@
 
         MutableComponent mutablecomponent1 = ComponentUtils.wrapInSquareBrackets(mutablecomponent);
         if (!this.isEmpty()) {
-            mutablecomponent1.withStyle(this.getRarity().color())
+            mutablecomponent1.withStyle(this.getRarity().getStyleModifier())
                 .withStyle(p_220170_ -> p_220170_.withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_ITEM, new HoverEvent.ItemStackInfo(this))));
         }
 
@@ -1014,6 +_,8 @@
         this.getItem().onUseTick(level, livingEntity, this, count);
     }
 
+    /** @deprecated Forge: Use {@linkplain net.neoforged.neoforge.common.extensions.IItemStackExtension#onDestroyed(ItemEntity, net.minecraft.world.damagesource.DamageSource) damage source sensitive version} */
+    @Deprecated
     public void onDestroyed(ItemEntity itemEntity) {
         this.getItem().onDestroyed(itemEntity);
     }
