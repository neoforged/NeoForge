--- a/net/minecraft/world/entity/player/Player.java
+++ b/net/minecraft/world/entity/player/Player.java
@@ -113,7 +_,8 @@
 import net.minecraft.world.scores.Team;
 import org.slf4j.Logger;
 
-public abstract class Player extends LivingEntity {
+public abstract class Player extends LivingEntity implements net.neoforged.neoforge.common.extensions.IPlayerExtension {
+    public static final String PERSISTED_NBT_TAG = "PlayerPersisted";
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final HumanoidArm DEFAULT_MAIN_HAND = HumanoidArm.RIGHT;
     public static final int DEFAULT_MODEL_CUSTOMIZATION = 0;
@@ -193,6 +_,9 @@
     public Entity currentExplosionCause;
     private boolean ignoreFallDamageFromCurrentImpulse;
     private int currentImpulseContextResetGraceTime;
+    private final java.util.Collection<MutableComponent> prefixes = new java.util.LinkedList<>();
+    private final java.util.Collection<MutableComponent> suffixes = new java.util.LinkedList<>();
+    @Nullable private Pose forcedPose;
 
     public Player(Level level, BlockPos pos, float yRot, GameProfile gameProfile) {
         super(EntityType.PLAYER, level);
@@ -229,7 +_,8 @@
             .add(Attributes.SUBMERGED_MINING_SPEED)
             .add(Attributes.SNEAKING_SPEED)
             .add(Attributes.MINING_EFFICIENCY)
-            .add(Attributes.SWEEPING_DAMAGE_RATIO);
+            .add(Attributes.SWEEPING_DAMAGE_RATIO)
+            .add(net.neoforged.neoforge.common.NeoForgeMod.CREATIVE_FLIGHT);
     }
 
     @Override
@@ -245,6 +_,7 @@
 
     @Override
     public void tick() {
+        net.neoforged.neoforge.event.EventHooks.firePlayerTickPre(this);
         this.noPhysics = this.isSpectator();
         if (this.isSpectator()) {
             this.setOnGround(false);
@@ -260,7 +_,7 @@
                 this.sleepCounter = 100;
             }
 
-            if (!this.level().isClientSide && this.level().isDay()) {
+            if (!this.level().isClientSide && !net.neoforged.neoforge.event.EventHooks.canEntityContinueSleeping(this, this.level().isDay() ? BedSleepingProblem.NOT_POSSIBLE_NOW : null)) {
                 this.stopSleepInBed(false, true);
             }
         } else if (this.sleepCounter > 0) {
@@ -318,6 +_,7 @@
         if (this.currentImpulseContextResetGraceTime > 0) {
             this.currentImpulseContextResetGraceTime--;
         }
+        net.neoforged.neoforge.event.EventHooks.firePlayerTickPost(this);
     }
 
     @Override
@@ -397,6 +_,10 @@
     }
 
     protected void updatePlayerPose() {
+        if(forcedPose != null) {
+            this.setPose(forcedPose);
+            return;
+        }
         if (this.canPlayerFitWithinBlocksAndEntitiesWhen(Pose.SWIMMING)) {
             Pose pose;
             if (this.isFallFlying()) {
@@ -630,6 +_,7 @@
 
     @Override
     public void die(DamageSource cause) {
+        if (net.neoforged.neoforge.common.CommonHooks.onLivingDeath(this, cause)) return;
         super.die(cause);
         this.reapplyPosition();
         if (!this.isSpectator() && this.level() instanceof ServerLevel serverlevel) {
@@ -684,7 +_,7 @@
 
     @Nullable
     public ItemEntity drop(ItemStack itemStack, boolean includeThrowerName) {
-        return this.drop(itemStack, false, includeThrowerName);
+        return net.neoforged.neoforge.common.CommonHooks.onPlayerTossEvent(this, itemStack, includeThrowerName);
     }
 
     @Nullable
@@ -726,7 +_,12 @@
         }
     }
 
+    @Deprecated //Use location sensitive version below
     public float getDestroySpeed(BlockState state) {
+        return getDigSpeed(state, null);
+    }
+
+    public float getDigSpeed(BlockState state, @Nullable BlockPos pos) {
         float f = this.inventory.getDestroySpeed(state);
         if (f > 1.0F) {
             f += (float)this.getAttributeValue(Attributes.MINING_EFFICIENCY);
@@ -754,13 +_,19 @@
             f /= 5.0F;
         }
 
+        f = net.neoforged.neoforge.event.EventHooks.getBreakSpeed(this, state, f, pos);
         return f;
     }
 
+    @Deprecated // Neo: use position sensitive version below
     public boolean hasCorrectToolForDrops(BlockState state) {
         return !state.requiresCorrectToolForDrops() || this.inventory.getSelected().isCorrectToolForDrops(state);
     }
 
+    public boolean hasCorrectToolForDrops(BlockState state, Level level, BlockPos pos) {
+        return net.neoforged.neoforge.event.EventHooks.doPlayerHarvestCheck(this, state, level, pos);
+    }
+
     @Override
     public void readAdditionalSaveData(CompoundTag compound) {
         super.readAdditionalSaveData(compound);
@@ -872,7 +_,9 @@
                     this.removeEntitiesOnShoulder();
                 }
 
-                if (source.scalesWithDifficulty()) {
+                amount = Math.max(0.0F, source.type().scaling().getScalingFunction().scaleDamage(source, this, amount, this.level().getDifficulty()));
+
+                if (false && source.scalesWithDifficulty()) {
                     if (this.level().getDifficulty() == Difficulty.PEACEFUL) {
                         amount = 0.0F;
                     }
@@ -926,7 +_,7 @@
 
     @Override
     protected void hurtCurrentlyUsedShield(float damage) {
-        if (this.useItem.is(Items.SHIELD)) {
+        if (this.useItem.canPerformAction(net.neoforged.neoforge.common.ItemAbilities.SHIELD_BLOCK)) {
             if (!this.level().isClientSide) {
                 this.awardStat(Stats.ITEM_USED.get(this.useItem.getItem()));
             }
@@ -934,7 +_,13 @@
             if (damage >= 3.0F) {
                 int i = 1 + Mth.floor(damage);
                 InteractionHand interactionhand = this.getUsedItemHand();
-                this.useItem.hurtAndBreak(i, this, getSlotForHand(interactionhand));
+                if (this.level() instanceof ServerLevel serverlevel && !hasInfiniteMaterials()) {
+                    this.useItem.hurtAndBreak(i, serverlevel, this, item -> {
+                        this.onEquippedItemBroken(item, getSlotForHand(interactionhand));
+                        net.neoforged.neoforge.event.EventHooks.onPlayerDestroyItem(this, this.useItem, interactionhand);
+                        stopUsingItem(); // Neo: Fix MC-168573 ("After breaking a shield, the player's off-hand can't finish using some items")
+                    });
+                }
                 if (this.useItem.isEmpty()) {
                     if (interactionhand == InteractionHand.MAIN_HAND) {
                         this.setItemSlot(EquipmentSlot.MAINHAND, ItemStack.EMPTY);
@@ -952,11 +_,14 @@
     @Override
     protected void actuallyHurt(DamageSource damageSrc, float damageAmount) {
         if (!this.isInvulnerableTo(damageSrc)) {
-            damageAmount = this.getDamageAfterArmorAbsorb(damageSrc, damageAmount);
-            damageAmount = this.getDamageAfterMagicAbsorb(damageSrc, damageAmount);
-            float f1 = Math.max(damageAmount - this.getAbsorptionAmount(), 0.0F);
-            this.setAbsorptionAmount(this.getAbsorptionAmount() - (damageAmount - f1));
-            float f = damageAmount - f1;
+            this.damageContainers.peek().setReduction(net.neoforged.neoforge.common.damagesource.DamageContainer.Reduction.ARMOR, this.damageContainers.peek().getNewDamage() - this.getDamageAfterArmorAbsorb(damageSrc, this.damageContainers.peek().getNewDamage()));
+            this.getDamageAfterMagicAbsorb(damageSrc, this.damageContainers.peek().getNewDamage());
+            float damage = this.damageContainers.peek().getNewDamage();
+            this.damageContainers.peek().setReduction(net.neoforged.neoforge.common.damagesource.DamageContainer.Reduction.ABSORPTION, Math.min(this.getAbsorptionAmount(), damage));
+            float absorbed = Math.min(damage, this.damageContainers.peek().getReduction(net.neoforged.neoforge.common.damagesource.DamageContainer.Reduction.ABSORPTION));
+            this.setAbsorptionAmount(Math.max(0, this.getAbsorptionAmount() - absorbed));
+            float f1 = net.neoforged.neoforge.common.CommonHooks.onLivingDamagePre(this, this.damageContainers.peek());
+            float f = absorbed;
             if (f > 0.0F && f < 3.4028235E37F) {
                 this.awardStat(Stats.DAMAGE_ABSORBED, Math.round(f * 10.0F));
             }
@@ -970,7 +_,9 @@
                 }
 
                 this.gameEvent(GameEvent.ENTITY_DAMAGE);
+                this.onDamageTaken(this.damageContainers.peek());
             }
+            net.neoforged.neoforge.common.CommonHooks.onLivingDamagePost(this, this.damageContainers.peek());
         }
     }
 
@@ -1014,6 +_,8 @@
 
             return InteractionResult.PASS;
         } else {
+            InteractionResult cancelResult = net.neoforged.neoforge.common.CommonHooks.onInteractEntity(this, entityToInteractOn, hand);
+            if (cancelResult != null) return cancelResult;
             ItemStack itemstack = this.getItemInHand(hand);
             ItemStack itemstack1 = itemstack.copy();
             InteractionResult interactionresult = entityToInteractOn.interact(this, hand);
@@ -1022,6 +_,9 @@
                     itemstack.setCount(itemstack1.getCount());
                 }
 
+                if (!this.abilities.instabuild && itemstack.isEmpty()) {
+                    net.neoforged.neoforge.event.EventHooks.onPlayerDestroyItem(this, itemstack1, hand);
+                }
                 return interactionresult;
             } else {
                 if (!itemstack.isEmpty() && entityToInteractOn instanceof LivingEntity) {
@@ -1033,6 +_,7 @@
                     if (interactionresult1.consumesAction()) {
                         this.level().gameEvent(GameEvent.ENTITY_INTERACT, entityToInteractOn.position(), GameEvent.Context.of(this));
                         if (itemstack.isEmpty() && !this.abilities.instabuild) {
+                            net.neoforged.neoforge.event.EventHooks.onPlayerDestroyItem(this, itemstack1, hand);
                             this.setItemInHand(hand, ItemStack.EMPTY);
                         }
 
@@ -1062,6 +_,7 @@
     }
 
     @Override
+    // Forge: Don't update this method to use IForgeEntity#getStepHeight() - https://github.com/MinecraftForge/MinecraftForge/issues/8922
     protected Vec3 maybeBackOffFromEdge(Vec3 vec, MoverType mover) {
         float f = this.maxUpStep();
         if (!this.abilities.flying
@@ -1111,6 +_,7 @@
         }
     }
 
+    // Forge: Don't update this method to use IForgeEntity#getStepHeight() - https://github.com/MinecraftForge/MinecraftForge/issues/9376
     private boolean isAboveGround(float maxUpStep) {
         return this.onGround() || this.fallDistance < maxUpStep && !this.canFallAtLeast(0.0, 0.0, maxUpStep - this.fallDistance);
     }
@@ -1132,6 +_,7 @@
     }
 
     public void attack(Entity target) {
+        if (!net.neoforged.neoforge.common.CommonHooks.onPlayerAttackTarget(this, target)) return;
         if (target.isAttackable()) {
             if (!target.skipAttackInteraction(this)) {
                 float f = this.isAutoSpinAttack() ? this.autoSpinAttackDmg : (float)this.getAttributeValue(Attributes.ATTACK_DAMAGE);
@@ -1141,7 +_,6 @@
                 float f2 = this.getAttackStrengthScale(0.5F);
                 f *= 0.2F + f2 * f2 * 0.8F;
                 f1 *= f2;
-                this.resetAttackStrengthTicker();
                 if (target.getType().is(EntityTypeTags.REDIRECTABLE_PROJECTILE)
                     && target instanceof Projectile projectile
                     && projectile.deflect(ProjectileDeflection.AIM_DEFLECT, this, this, true)) {
@@ -1170,8 +_,12 @@
                         && !this.isPassenger()
                         && target instanceof LivingEntity
                         && !this.isSprinting();
+                    // Neo: Fire the critical hit event and override the critical hit status and damage multiplier based on the event.
+                    // The boolean local above (flag2) is the vanilla critical hit result.
+                    var critEvent = net.neoforged.neoforge.common.CommonHooks.fireCriticalHit(this, target, flag1, flag1 ? 1.5F : 1.0F);
+                    flag1 = critEvent.isCriticalHit();
                     if (flag1) {
-                        f *= 1.5F;
+                        f *= critEvent.getDamageMultiplier();
                     }
 
                     float f3 = f + f1;
@@ -1179,9 +_,7 @@
                     double d0 = (double)(this.walkDist - this.walkDistO);
                     if (flag4 && !flag1 && !flag && this.onGround() && d0 < (double)this.getSpeed()) {
                         ItemStack itemstack1 = this.getItemInHand(InteractionHand.MAIN_HAND);
-                        if (itemstack1.getItem() instanceof SwordItem) {
-                            flag2 = true;
-                        }
+                        flag2 = itemstack1.canPerformAction(net.neoforged.neoforge.common.ItemAbilities.SWORD_SWEEP);
                     }
 
                     float f6 = 0.0F;
@@ -1217,11 +_,12 @@
 
                             for (LivingEntity livingentity2 : this.level()
                                 .getEntitiesOfClass(LivingEntity.class, target.getBoundingBox().inflate(1.0, 0.25, 1.0))) {
+                                double entityReachSq = Mth.square(this.entityInteractionRange()); // Use entity reach instead of constant 9.0. Vanilla uses bottom center-to-center checks here, so don't update this to use canReach, since it uses closest-corner checks.
                                 if (livingentity2 != this
                                     && livingentity2 != target
                                     && !this.isAlliedTo(livingentity2)
                                     && (!(livingentity2 instanceof ArmorStand) || !((ArmorStand)livingentity2).isMarker())
-                                    && this.distanceToSqr(livingentity2) < 9.0) {
+                                    && this.distanceToSqr(livingentity2) < entityReachSq) {
                                     float f5 = this.getEnchantedDamage(livingentity2, f7, damagesource) * f2;
                                     livingentity2.knockback(
                                         0.4F,
@@ -1268,11 +_,12 @@
 
                         this.setLastHurtMob(target);
                         Entity entity = target;
-                        if (target instanceof EnderDragonPart) {
-                            entity = ((EnderDragonPart)target).parentMob;
+                        if (target instanceof net.neoforged.neoforge.entity.PartEntity) {
+                            entity = ((net.neoforged.neoforge.entity.PartEntity<?>) target).getParent();
                         }
 
                         boolean flag5 = false;
+                        ItemStack copy = itemstack.copy();
                         if (this.level() instanceof ServerLevel serverlevel1) {
                             if (entity instanceof LivingEntity livingentity3) {
                                 flag5 = itemstack.hurtEnemy(livingentity3, this);
@@ -1287,6 +_,7 @@
                             }
 
                             if (itemstack.isEmpty()) {
+                                net.neoforged.neoforge.event.EventHooks.onPlayerDestroyItem(this, copy, itemstack == this.getMainHandItem() ? InteractionHand.MAIN_HAND : InteractionHand.OFF_HAND);
                                 if (itemstack == this.getMainHandItem()) {
                                     this.setItemInHand(InteractionHand.MAIN_HAND, ItemStack.EMPTY);
                                 } else {
@@ -1311,6 +_,7 @@
                             .playSound(null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_NODAMAGE, this.getSoundSource(), 1.0F, 1.0F);
                     }
                 }
+                this.resetAttackStrengthTicker(); // FORGE: Moved from beginning of attack() so that getAttackStrengthScale() returns an accurate value during all attack events
             }
         }
     }
@@ -1325,7 +_,7 @@
     }
 
     public void disableShield() {
-        this.getCooldowns().addCooldown(Items.SHIELD, 100);
+        this.getCooldowns().addCooldown(this.getUseItem().getItem(), 100);
         this.stopUsingItem();
         this.level().broadcastEntityEvent(this, (byte)30);
     }
@@ -1391,6 +_,7 @@
     }
 
     public void stopSleepInBed(boolean wakeImmediately, boolean updateLevelForSleepingPlayers) {
+        net.neoforged.neoforge.event.EventHooks.onPlayerWakeup(this, wakeImmediately, updateLevelForSleepingPlayers);
         super.stopSleeping();
         if (this.level() instanceof ServerLevel && updateLevelForSleepingPlayers) {
             ((ServerLevel)this.level()).updateSleepingPlayerList();
@@ -1503,7 +_,8 @@
 
     @Override
     public boolean causeFallDamage(float fallDistance, float multiplier, DamageSource source) {
-        if (this.abilities.mayfly) {
+        if (this.mayFly()) {
+            net.neoforged.neoforge.event.EventHooks.onPlayerFall(this, fallDistance, fallDistance);
             return false;
         } else {
             if (fallDistance >= 2.0F) {
@@ -1535,7 +_,7 @@
     public boolean tryToStartFallFlying() {
         if (!this.onGround() && !this.isFallFlying() && !this.isInWater() && !this.hasEffect(MobEffects.LEVITATION)) {
             ItemStack itemstack = this.getItemBySlot(EquipmentSlot.CHEST);
-            if (itemstack.is(Items.ELYTRA) && ElytraItem.isFlyEnabled(itemstack)) {
+            if (itemstack.canElytraFly(this)) {
                 this.startFallFlying();
                 return true;
             }
@@ -1564,13 +_,13 @@
     protected void playStepSound(BlockPos pos, BlockState state) {
         if (this.isInWater()) {
             this.waterSwimSound();
-            this.playMuffledStepSound(state);
+            this.playMuffledStepSound(state, pos);
         } else {
             BlockPos blockpos = this.getPrimaryStepSoundBlockPos(pos);
             if (!pos.equals(blockpos)) {
                 BlockState blockstate = this.level().getBlockState(blockpos);
                 if (blockstate.is(BlockTags.COMBINATION_STEP_SOUND_BLOCKS)) {
-                    this.playCombinationStepSounds(blockstate, state);
+                    this.playCombinationStepSounds(blockstate, state, blockpos, pos);
                 } else {
                     super.playStepSound(blockpos, blockstate);
                 }
@@ -1601,6 +_,10 @@
     }
 
     public void giveExperiencePoints(int xpPoints) {
+        net.neoforged.neoforge.event.entity.player.PlayerXpEvent.XpChange event = new net.neoforged.neoforge.event.entity.player.PlayerXpEvent.XpChange(this, xpPoints);
+        if (net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(event).isCanceled()) return;
+        xpPoints = event.getAmount();
+
         this.increaseScore(xpPoints);
         this.experienceProgress = this.experienceProgress + (float)xpPoints / (float)this.getXpNeededForNextLevel();
         this.totalExperience = Mth.clamp(this.totalExperience + xpPoints, 0, Integer.MAX_VALUE);
@@ -1628,7 +_,7 @@
     }
 
     public void onEnchantmentPerformed(ItemStack enchantedItem, int levelCost) {
-        this.experienceLevel -= levelCost;
+        giveExperienceLevels(-levelCost);
         if (this.experienceLevel < 0) {
             this.experienceLevel = 0;
             this.experienceProgress = 0.0F;
@@ -1639,6 +_,10 @@
     }
 
     public void giveExperienceLevels(int levels) {
+        net.neoforged.neoforge.event.entity.player.PlayerXpEvent.LevelChange event = new net.neoforged.neoforge.event.entity.player.PlayerXpEvent.LevelChange(this, levels);
+        if (net.neoforged.neoforge.common.NeoForge.EVENT_BUS.post(event).isCanceled()) return;
+        levels = event.getLevels();
+
         this.experienceLevel += levels;
         if (this.experienceLevel < 0) {
             this.experienceLevel = 0;
@@ -1847,7 +_,11 @@
 
     @Override
     public Component getDisplayName() {
-        MutableComponent mutablecomponent = PlayerTeam.formatNameForTeam(this.getTeam(), this.getName());
+        if (this.displayname == null) this.displayname = net.neoforged.neoforge.event.EventHooks.getPlayerDisplayName(this, this.getName());
+        MutableComponent mutablecomponent = Component.literal("");
+        mutablecomponent = prefixes.stream().reduce(mutablecomponent, MutableComponent::append);
+        mutablecomponent = mutablecomponent.append(PlayerTeam.formatNameForTeam(this.getTeam(), this.displayname));
+        mutablecomponent = suffixes.stream().reduce(mutablecomponent, MutableComponent::append);
         return this.decorateDisplayNameComponent(mutablecomponent);
     }
 
@@ -2012,18 +_,18 @@
             Predicate<ItemStack> predicate = ((ProjectileWeaponItem)shootable.getItem()).getSupportedHeldProjectiles();
             ItemStack itemstack = ProjectileWeaponItem.getHeldProjectile(this, predicate);
             if (!itemstack.isEmpty()) {
-                return itemstack;
+                return net.neoforged.neoforge.common.CommonHooks.getProjectile(this, shootable, itemstack);
             } else {
                 predicate = ((ProjectileWeaponItem)shootable.getItem()).getAllSupportedProjectiles();
 
                 for (int i = 0; i < this.inventory.getContainerSize(); i++) {
                     ItemStack itemstack1 = this.inventory.getItem(i);
                     if (predicate.test(itemstack1)) {
-                        return itemstack1;
+                        return net.neoforged.neoforge.common.CommonHooks.getProjectile(this, shootable, itemstack1);
                     }
                 }
 
-                return this.abilities.instabuild ? new ItemStack(Items.ARROW) : ItemStack.EMPTY;
+                return net.neoforged.neoforge.common.CommonHooks.getProjectile(this, shootable, this.abilities.instabuild ? ((ProjectileWeaponItem)shootable.getItem()).getDefaultCreativeAmmo(this, shootable) : ItemStack.EMPTY);
             }
         }
     }
@@ -2201,5 +_,41 @@
         public Component getMessage() {
             return this.message;
         }
+    }
+
+    // Neo: Getters for the Player's name prefixes and suffixes
+    public Collection<MutableComponent> getPrefixes() {
+         return this.prefixes;
+    }
+
+    public Collection<MutableComponent> getSuffixes() {
+         return this.suffixes;
+    }
+
+    private Component displayname = null;
+
+    /**
+     * Neo: Force the displayed name to refresh, by firing {@link net.neoforged.neoforge.event.entity.player.PlayerEvent.NameFormat}, using the real player name as event parameter.
+     */
+    public void refreshDisplayName() {
+        this.displayname = net.neoforged.neoforge.event.EventHooks.getPlayerDisplayName(this, this.getName());
+    }
+
+    /**
+     * Neo: Force a pose for the player. If set, the vanilla pose determination and clearance check is skipped. Make sure the pose is clear yourself (e.g. in PlayerTick).
+     * This has to be set just once, do not set it every tick.
+     * Make sure to clear (null) the pose if not required anymore and only use if necessary.
+     */
+    public void setForcedPose(@Nullable Pose pose) {
+        this.forcedPose = pose;
+    }
+
+    /**
+     * Neo:
+     * @return The forced pose if set, null otherwise
+     */
+    @Nullable
+    public Pose getForcedPose() {
+        return this.forcedPose;
     }
 }
