--- a/net/minecraft/data/tags/TagsProvider.java
+++ b/net/minecraft/data/tags/TagsProvider.java
@@ -32,26 +_,54 @@
     private final CompletableFuture<TagsProvider.TagLookup<T>> parentProvider;
     protected final ResourceKey<? extends Registry<T>> registryKey;
     protected final Map<ResourceLocation, TagBuilder> builders = Maps.newLinkedHashMap();
+    protected final String modId;
+    @org.jetbrains.annotations.Nullable
+    protected final net.neoforged.neoforge.common.data.ExistingFileHelper existingFileHelper;
+    private final net.neoforged.neoforge.common.data.ExistingFileHelper.IResourceType resourceType;
+    private final net.neoforged.neoforge.common.data.ExistingFileHelper.IResourceType elementResourceType; // FORGE: Resource type for validating required references to datapack registry elements.
 
+    /**
+     * @deprecated Forge: Use the {@linkplain #TagsProvider(PackOutput, ResourceKey, CompletableFuture, String, net.neoforged.neoforge.common.data.ExistingFileHelper) mod id variant}
+     */
     protected TagsProvider(PackOutput output, ResourceKey<? extends Registry<T>> registryKey, CompletableFuture<HolderLookup.Provider> lookupProvider) {
-        this(output, registryKey, lookupProvider, CompletableFuture.completedFuture(TagsProvider.TagLookup.empty()));
+        this(output, registryKey, lookupProvider, "vanilla", null);
+    }
+    protected TagsProvider(PackOutput output, ResourceKey<? extends Registry<T>> registryKey, CompletableFuture<HolderLookup.Provider> lookupProvider, String modId, @org.jetbrains.annotations.Nullable net.neoforged.neoforge.common.data.ExistingFileHelper existingFileHelper) {
+        this(output, registryKey, lookupProvider, CompletableFuture.completedFuture(TagsProvider.TagLookup.empty()), modId, existingFileHelper);
     }
 
+    /**
+     * @deprecated Forge: Use the {@linkplain #TagsProvider(PackOutput, ResourceKey, CompletableFuture, CompletableFuture, String, net.neoforged.neoforge.common.data.ExistingFileHelper) mod id variant}
+     */
+    @Deprecated
     protected TagsProvider(
         PackOutput output,
         ResourceKey<? extends Registry<T>> registryKey,
         CompletableFuture<HolderLookup.Provider> lookupProvider,
         CompletableFuture<TagsProvider.TagLookup<T>> parentProvider
     ) {
+        this(output, registryKey, lookupProvider, parentProvider, "vanilla", null);
+    }
+    protected TagsProvider(PackOutput output, ResourceKey<? extends Registry<T>> registryKey, CompletableFuture<HolderLookup.Provider> lookupProvider, CompletableFuture<TagsProvider.TagLookup<T>> parentProvider, String modId, @org.jetbrains.annotations.Nullable net.neoforged.neoforge.common.data.ExistingFileHelper existingFileHelper) {
         this.pathProvider = output.createRegistryTagsPathProvider(registryKey);
         this.registryKey = registryKey;
         this.parentProvider = parentProvider;
         this.lookupProvider = lookupProvider;
+        this.modId = modId;
+        this.existingFileHelper = existingFileHelper;
+        this.resourceType = new net.neoforged.neoforge.common.data.ExistingFileHelper.ResourceType(net.minecraft.server.packs.PackType.SERVER_DATA, ".json", net.minecraft.core.registries.Registries.tagsDirPath(registryKey));
+        this.elementResourceType = new net.neoforged.neoforge.common.data.ExistingFileHelper.ResourceType(net.minecraft.server.packs.PackType.SERVER_DATA, ".json", net.neoforged.neoforge.common.CommonHooks.prefixNamespace(registryKey.location()));
+    }
+
+    // Forge: Allow customizing the path for a given tag or returning null
+    @org.jetbrains.annotations.Nullable
+    protected Path getPath(ResourceLocation id) {
+        return this.pathProvider.json(id);
     }
 
     @Override
     public String getName() {
-        return "Tags for " + this.registryKey.location();
+        return "Tags for " + this.registryKey.location() + " mod id " + this.modId;
     }
 
     protected abstract void addTags(HolderLookup.Provider provider);
@@ -84,7 +_,10 @@
                                     ResourceLocation resourcelocation = p_323138_.getKey();
                                     TagBuilder tagbuilder = p_323138_.getValue();
                                     List<TagEntry> list = tagbuilder.build();
-                                    List<TagEntry> list1 = list.stream().filter(p_274771_ -> !p_274771_.verifyIfPresent(predicate, predicate1)).toList();
+                                    List<TagEntry> list1 = java.util.stream.Stream.concat(list.stream(), tagbuilder.getRemoveEntries())
+                                              .filter((p_274771_) -> !p_274771_.verifyIfPresent(predicate, predicate1))
+                                              .filter(this::missing)
+                                              .toList();
                                     if (!list1.isEmpty()) {
                                         throw new IllegalArgumentException(
                                             String.format(
@@ -95,8 +_,10 @@
                                             )
                                         );
                                     } else {
-                                        Path path = this.pathProvider.json(resourcelocation);
-                                        return DataProvider.saveStable(output, p_323140_.contents, TagFile.CODEC, new TagFile(list, false), path);
+                                        Path path = this.getPath(resourcelocation);
+                                        if (path == null) return CompletableFuture.completedFuture(null); // Neo: Allow running this data provider without writing it. Recipe provider needs valid tags.
+                                        var removed = tagbuilder.getRemoveEntries().toList();
+                                        return DataProvider.saveStable(output, p_323140_.contents, TagFile.CODEC, new TagFile(list, tagbuilder.isReplace(), removed), path);
                                     }
                                 }
                             )
@@ -106,12 +_,24 @@
             );
     }
 
+    private boolean missing(TagEntry reference) {
+        // Optional tags should not be validated
+
+        if (reference.isRequired()) {
+            return existingFileHelper == null || !existingFileHelper.exists(reference.getId(), reference.isTag() ? resourceType : elementResourceType);
+        }
+        return false;
+    }
+
     protected TagsProvider.TagAppender<T> tag(TagKey<T> tag) {
         TagBuilder tagbuilder = this.getOrCreateRawBuilder(tag);
-        return new TagsProvider.TagAppender<>(tagbuilder);
+        return new TagsProvider.TagAppender<>(tagbuilder, modId);
     }
 
     protected TagBuilder getOrCreateRawBuilder(TagKey<T> tag) {
+        if (existingFileHelper != null) {
+            existingFileHelper.trackGenerated(tag.location(), resourceType);
+        }
         return this.builders.computeIfAbsent(tag.location(), p_236442_ -> TagBuilder.create());
     }
 
@@ -127,11 +_,13 @@
         });
     }
 
-    public static class TagAppender<T> {
+    public static class TagAppender<T> implements net.neoforged.neoforge.common.extensions.ITagAppenderExtension<T> {
         private final TagBuilder builder;
+        private final String modId;
 
-        protected TagAppender(TagBuilder builder) {
-            this.builder = builder;
+        protected TagAppender(TagBuilder p_236454_, String modId) {
+            this.builder = p_236454_;
+            this.modId = modId;
         }
 
         public final TagsProvider.TagAppender<T> add(ResourceKey<T> key) {
@@ -169,6 +_,19 @@
         public TagsProvider.TagAppender<T> addOptionalTag(ResourceLocation location) {
             this.builder.addOptionalTag(location);
             return this;
+        }
+
+        public TagsProvider.TagAppender<T> add(TagEntry tag) {
+             builder.add(tag);
+             return this;
+        }
+
+        public TagBuilder getInternalBuilder() {
+             return builder;
+        }
+
+        public String getModID() {
+             return modId;
         }
     }
 
